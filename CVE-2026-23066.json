{
  "id": "CVE-2026-23066",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-04T17:16:17.303",
  "lastModified": "2026-02-05T14:57:20.563",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix recvmsg() unconditional requeue\n\nIf rxrpc_recvmsg() fails because MSG_DONTWAIT was specified but the call at\nthe front of the recvmsg queue already has its mutex locked, it requeues\nthe call - whether or not the call is already queued.  The call may be on\nthe queue because MSG_PEEK was also passed and so the call was not dequeued\nor because the I/O thread requeued it.\n\nThe unconditional requeue may then corrupt the recvmsg queue, leading to\nthings like UAFs or refcount underruns.\n\nFix this by only requeuing the call if it isn't already on the queue - and\nmoving it to the front if it is already queued.  If we don't queue it, we\nhave to put the ref we obtained by dequeuing it.\n\nAlso, MSG_PEEK doesn't dequeue the call so shouldn't call\nrxrpc_notify_socket() for the call if we didn't use up all the data on the\nqueue, so fix that also."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nrxrpc: Corrección del reenqueque incondicional de recvmsg()\n\nSi rxrpc_recvmsg() falla porque se especificó MSG_DONTWAIT pero la llamada al frente de la cola de recvmsg ya tiene su mutex bloqueado, reenquequea la llamada, esté o no la llamada ya en la cola. La llamada puede estar en la cola porque también se pasó MSG_PEEK y por lo tanto la llamada no fue desencolada o porque el hilo de E/S la reenquequeó.\n\nEl reenqueque incondicional puede entonces corromper la cola de recvmsg, lo que lleva a cosas como UAFs o subdesbordamientos de refcount.\n\nSolucione esto reenquequeando la llamada solo si no está ya en la cola, y moviéndola al frente si ya está en la cola. Si no la encolamos, tenemos que liberar la referencia que obtuvimos al desencolarla.\n\nAdemás, MSG_PEEK no desencola la llamada, por lo que no debería llamar a rxrpc_notify_socket() para la llamada si no consumimos todos los datos de la cola, así que corrija eso también."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2c28769a51deb6022d7fbd499987e237a01dd63a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/930114425065f7ace6e0c0630fab4af75e059ea8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}