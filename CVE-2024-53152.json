{
  "id": "CVE-2024-53152",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-12-24T12:15:23.353",
  "lastModified": "2025-10-08T14:43:44.923",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: tegra194: Move controller cleanups to pex_ep_event_pex_rst_deassert()\n\nCurrently, the endpoint cleanup function dw_pcie_ep_cleanup() and EPF\ndeinit notify function pci_epc_deinit_notify() are called during the\nexecution of pex_ep_event_pex_rst_assert() i.e., when the host has asserted\nPERST#. But quickly after this step, refclk will also be disabled by the\nhost.\n\nAll of the tegra194 endpoint SoCs supported as of now depend on the refclk\nfrom the host for keeping the controller operational. Due to this\nlimitation, any access to the hardware registers in the absence of refclk\nwill result in a whole endpoint crash. Unfortunately, most of the\ncontroller cleanups require accessing the hardware registers (like eDMA\ncleanup performed in dw_pcie_ep_cleanup(), etc...). So these cleanup\nfunctions can cause the crash in the endpoint SoC once host asserts PERST#.\n\nOne way to address this issue is by generating the refclk in the endpoint\nitself and not depending on the host. But that is not always possible as\nsome of the endpoint designs do require the endpoint to consume refclk from\nthe host.\n\nThus, fix this crash by moving the controller cleanups to the start of\nthe pex_ep_event_pex_rst_deassert() function. This function is called\nwhenever the host has deasserted PERST# and it is guaranteed that the\nrefclk would be active at this point. So at the start of this function\n(after enabling resources) the controller cleanup can be performed. Once\nfinished, rest of the code execution for PERST# deassert can continue as\nusual."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: PCI: tegra194: Mover las desinfecciones del controlador a pex_ep_event_pex_rst_deassert(). Actualmente, la función de desinfección de endpoints dw_pcie_ep_cleanup() y la función de notificación deinit de EPF pci_epc_deinit_notify() se llaman durante la ejecución de pex_ep_event_pex_rst_assert(), es decir , cuando el anfitrión tiene afirmó PREST#. Pero poco después de este paso, el host también desactivará refclk. Todos los SoC de endpoint tegra194 admitidos a partir de ahora dependen de la refclk del host para mantener el controlador operativo. Debido a esta limitación, cualquier acceso a los registros de hardware en ausencia de refclk resultará en una falla completa del endpoint. Desafortunadamente, la mayoría de las desinfecciones del controlador requieren acceder a los registros de hardware (como la desinfección eDMA realizada en dw_pcie_ep_cleanup(), etc...). Por lo tanto, estas funciones de desinfección pueden provocar el bloqueo del SoC del endpoint una vez que el host afirma el número PREST. Una forma de abordar este problema es generando el refclk en el propio endpoint y sin depender del host. Pero eso no siempre es posible ya que algunos de los diseños de terminales requieren que el terminal consuma refclk del host. Por lo tanto, solucione este bloqueo moviendo las desinfecciones del controlador al inicio de la función pex_ep_event_pex_rst_deassert(). Esta función se llama siempre que el host ha anulado PERST# y se garantiza que refclk estará activo en este punto. Entonces, al inicio de esta función (después de habilitar los recursos), se puede realizar la desinfección del controlador. Una vez finalizado, el resto de la ejecución del código para la desactivación de PERST# puede continuar como de costumbre."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "NVD-CWE-noinfo"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.10",
              "versionEndExcluding": "6.11.11",
              "matchCriteriaId": "158A6B22-9260-41D7-965A-A81798A5A969"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.12",
              "versionEndExcluding": "6.12.2",
              "matchCriteriaId": "D8882B1B-2ABC-4838-AC1D-DBDBB5764776"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/40e2125381dc11379112485e3eefdd25c6df5375",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/70212c2300971506e986d95000d2745529cac9d7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/72034050ccf4202cd6558b0afd2474f756ea3b9b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}