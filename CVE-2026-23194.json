{
  "id": "CVE-2026-23194",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T17:15:57.233",
  "lastModified": "2026-02-18T17:52:22.253",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrust_binder: correctly handle FDA objects of length zero\n\nFix a bug where an empty FDA (fd array) object with 0 fds would cause an\nout-of-bounds error. The previous implementation used `skip == 0` to\nmean \"this is a pointer fixup\", but 0 is also the correct skip length\nfor an empty FDA. If the FDA is at the end of the buffer, then this\nresults in an attempt to write 8-bytes out of bounds. This is caught and\nresults in an EINVAL error being returned to userspace.\n\nThe pattern of using `skip == 0` as a special value originates from the\nC-implementation of Binder. As part of fixing this bug, this pattern is\nreplaced with a Rust enum.\n\nI considered the alternate option of not pushing a fixup when the length\nis zero, but I think it's cleaner to just get rid of the zero-is-special\nstuff.\n\nThe root cause of this bug was diagnosed by Gemini CLI on first try. I\nused the following prompt:\n\n> There appears to be a bug in @drivers/android/binder/thread.rs where\n> the Fixups oob bug is triggered with 316 304 316 324. This implies\n> that we somehow ended up with a fixup where buffer A has a pointer to\n> buffer B, but the pointer is located at an index in buffer A that is\n> out of bounds. Please investigate the code to find the bug. You may\n> compare with @drivers/android/binder.c that implements this correctly."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nrust_binder: manejar correctamente los objetos FDA de longitud cero\n\nSe corrige un error donde un objeto FDA (matriz de descriptores de archivo) vacío con 0 descriptores de archivo causaría un error de fuera de límites. La implementación anterior utilizaba 'skip == 0' para significar 'esto es una corrección de puntero', pero 0 es también la longitud de salto correcta para un FDA vacío. Si el FDA está al final del búfer, entonces esto resulta en un intento de escribir 8 bytes fuera de los límites. Esto es detectado y resulta en que se devuelve un error EINVAL al espacio de usuario.\n\nEl patrón de usar 'skip == 0' como un valor especial se origina en la implementación en C de Binder. Como parte de la corrección de este error, este patrón es reemplazado con un enum de Rust.\n\nConsideré la opción alternativa de no aplicar una corrección cuando la longitud es cero, pero creo que es más limpio simplemente eliminar lo de \"cero es especial\".\n\nLa causa raíz de este error fue diagnosticada por Gemini CLI al primer intento. Utilicé el siguiente prompt:\n\n&gt; Parece haber un error en @drivers/android/binder/thread.rs donde el error de fuera de límites (oob) de Fixups se activa con 316 304 316 324. Esto implica que de alguna manera terminamos con una corrección donde el búfer A tiene un puntero al búfer B, pero el puntero está ubicado en un índice en el búfer A que está fuera de los límites. Por favor, investigue el código para encontrar el error. Puede comparar con @drivers/android/binder.c que implementa esto correctamente."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/598fe3ff32e43918ed8a062f55432b3d23e6340c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8f589c9c3be539d6c2b393c82940c3783831082f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}