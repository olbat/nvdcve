{
  "id": "CVE-2026-23177",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T17:15:55.430",
  "lastModified": "2026-02-18T17:52:22.253",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm, shmem: prevent infinite loop on truncate race\n\nWhen truncating a large swap entry, shmem_free_swap() returns 0 when the\nentry's index doesn't match the given index due to lookup alignment.  The\nfailure fallback path checks if the entry crosses the end border and\naborts when it happens, so truncate won't erase an unexpected entry or\nrange.  But one scenario was ignored.\n\nWhen `index` points to the middle of a large swap entry, and the large\nswap entry doesn't go across the end border, find_get_entries() will\nreturn that large swap entry as the first item in the batch with\n`indices[0]` equal to `index`.  The entry's base index will be smaller\nthan `indices[0]`, so shmem_free_swap() will fail and return 0 due to the\n\"base < index\" check.  The code will then call shmem_confirm_swap(), get\nthe order, check if it crosses the END boundary (which it doesn't), and\nretry with the same index.\n\nThe next iteration will find the same entry again at the same index with\nsame indices, leading to an infinite loop.\n\nFix this by retrying with a round-down index, and abort if the index is\nsmaller than the truncate range."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nmm, shmem: evitar bucle infinito en una condición de carrera de truncamiento\n\nAl truncar una entrada de intercambio grande, shmem_free_swap() devuelve 0 cuando el índice de la entrada no coincide con el índice dado debido a la alineación de búsqueda. La ruta de retroceso en caso de fallo comprueba si la entrada cruza el borde final y aborta cuando esto ocurre, por lo que el truncamiento no borrará una entrada o rango inesperado. Pero un escenario fue ignorado.\n\nCuando 'index' apunta al medio de una entrada de intercambio grande, y la entrada de intercambio grande no cruza el borde final, find_get_entries() devolverá esa entrada de intercambio grande como el primer elemento en el lote con 'indices[0]' igual a 'index'. El índice base de la entrada será menor que 'indices[0]', por lo que shmem_free_swap() fallará y devolverá 0 debido a la comprobación \"base &lt; index\". El código entonces llamará a shmem_confirm_swap(), obtendrá el orden, comprobará si cruza el límite END (lo cual no hace), y reintentará con el mismo índice.\n\nLa siguiente iteración encontrará la misma entrada de nuevo en el mismo índice con los mismos índices, lo que lleva a un bucle infinito.\n\nSolucione esto reintentando con un índice redondeado a la baja, y abortar si el índice es menor que el rango de truncamiento."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2030dddf95451b4e7a389f052091e7c4b7b274c6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7b6a0f121d50234aab3e7ab9a62ebe826d40a32a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/dfc3ab6bd64860f8022d69903be299d09be86e11",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}