{
  "id": "CVE-2026-23118",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T15:16:06.933",
  "lastModified": "2026-02-18T17:52:44.520",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix data-race warning and potential load/store tearing\n\nFix the following:\n\n        BUG: KCSAN: data-race in rxrpc_peer_keepalive_worker / rxrpc_send_data_packet\n\nwhich is reporting an issue with the reads and writes to ->last_tx_at in:\n\n        conn->peer->last_tx_at = ktime_get_seconds();\n\nand:\n\n        keepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;\n\nThe lockless accesses to these to values aren't actually a problem as the\nread only needs an approximate time of last transmission for the purposes\nof deciding whether or not the transmission of a keepalive packet is\nwarranted yet.\n\nAlso, as ->last_tx_at is a 64-bit value, tearing can occur on a 32-bit\narch.\n\nFix both of these by switching to an unsigned int for ->last_tx_at and only\nstoring the LSW of the time64_t.  It can then be reconstructed at need\nprovided no more than 68 years has elapsed since the last transmission."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nrxrpc: Corregir la advertencia de condición de carrera de datos y el potencial desgarro de carga/almacenamiento\n\nCorregir lo siguiente:\n\n        BUG: KCSAN: condición de carrera de datos en rxrpc_peer_keepalive_worker / rxrpc_send_data_packet\n\nque está informando un problema con las lecturas y escrituras a -&gt;last_tx_at en:\n\n        conn-&gt;peer-&gt;last_tx_at = ktime_get_seconds();\n\ny:\n\n        keepalive_at = peer-&gt;last_tx_at + RXRPC_KEEPALIVE_TIME;\n\nLos accesos sin bloqueo a estos dos valores no son realmente un problema, ya que la lectura solo necesita un tiempo aproximado de la última transmisión con el propósito de decidir si la transmisión de un paquete keepalive está justificada o no.\n\nAdemás, como -&gt;last_tx_at es un valor de 64 bits, puede ocurrir desgarro en una arquitectura de 32 bits.\n\nCorregir ambos cambiando a un unsigned int para -&gt;last_tx_at y almacenando solo el LSW del time64_t. Luego puede ser reconstruido cuando sea necesario, siempre que no hayan transcurrido más de 68 años desde la última transmisión."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/5d5fe8bcd331f1e34e0943ec7c18432edfcf0e8b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c08cf314191cd0f8699089715efb9eff030f0086",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f8cf1368e0a5491b27189a695c36f64e48f3d19d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}