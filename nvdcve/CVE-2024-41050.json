{
  "id": "CVE-2024-41050",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-29T15:15:13.260",
  "lastModified": "2024-11-21T09:32:08.500",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: cyclic allocation of msg_id to avoid reuse\n\nReusing the msg_id after a maliciously completed reopen request may cause\na read request to remain unprocessed and result in a hung, as shown below:\n\n       t1       |      t2       |      t3\n-------------------------------------------------\ncachefiles_ondemand_select_req\n cachefiles_ondemand_object_is_close(A)\n cachefiles_ondemand_set_object_reopening(A)\n queue_work(fscache_object_wq, &info->work)\n                ondemand_object_worker\n                 cachefiles_ondemand_init_object(A)\n                  cachefiles_ondemand_send_req(OPEN)\n                    // get msg_id 6\n                    wait_for_completion(&req_A->done)\ncachefiles_ondemand_daemon_read\n // read msg_id 6 req_A\n cachefiles_ondemand_get_fd\n copy_to_user\n                                // Malicious completion msg_id 6\n                                copen 6,-1\n                                cachefiles_ondemand_copen\n                                 complete(&req_A->done)\n                                 // will not set the object to close\n                                 // because ondemand_id && fd is valid.\n\n                // ondemand_object_worker() is done\n                // but the object is still reopening.\n\n                                // new open req_B\n                                cachefiles_ondemand_init_object(B)\n                                 cachefiles_ondemand_send_req(OPEN)\n                                 // reuse msg_id 6\nprocess_open_req\n copen 6,A.size\n // The expected failed copen was executed successfully\n\nExpect copen to fail, and when it does, it closes fd, which sets the\nobject to close, and then close triggers reopen again. However, due to\nmsg_id reuse resulting in a successful copen, the anonymous fd is not\nclosed until the daemon exits. Therefore read requests waiting for reopen\nto complete may trigger hung task.\n\nTo avoid this issue, allocate the msg_id cyclically to avoid reusing the\nmsg_id for a very short duration of time."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: archivos de caché: asignación cíclica de msg_id para evitar la reutilización La reutilización de msg_id después de una solicitud de reapertura completada maliciosamente puede causar que una solicitud de lectura permanezca sin procesar y resulte en un bloqueo, como se muestra a continuación: t1 | t2 | t3 ------------------------------------------------- cachefiles_ondemand_select_req cachefiles_ondemand_object_is_close(A) cachefiles_ondemand_set_object_reopening(A) queue_work(fscache_object_wq, &amp;info-&gt;work) ondemand_object_worker cachefiles_ondemand_init_object(A) cachefiles_ondemand_send_req(OPEN) // obtener msg_id 6 _completion(&amp;req_A-&gt;done) cachefiles_ondemand_daemon_read // leer msg_id 6 req_A cachefiles_ondemand_get_fd copy_to_user // Finalización maliciosa msg_id 6 copen 6,-1 cachefiles_ondemand_copen complete(&amp;req_A-&gt;done) // no configurará el objeto para que se cierre // porque ondemand_id &amp;&amp; fd es válido. // ondemand_object_worker() está listo // pero el objeto aún se está reabriendo. // new open req_B cachefiles_ondemand_init_object(B) cachefiles_ondemand_send_req(OPEN) // reutilizar msg_id 6 process_open_req copen 6,A.size // El copen fallido esperado se ejecutó con éxito Se espera que copen falle y, cuando lo hace, cierra fd, lo que establece el objeto se cierra y luego el cierre activa nuevamente. Sin embargo, debido a que la reutilización de msg_id da como resultado un copen exitoso, el fd anónimo no se cierra hasta que el demonio sale. Por lo tanto, las solicitudes de lectura que esperan que se complete la reapertura pueden desencadenar una tarea colgada. Para evitar este problema, asigne msg_id cíclicamente para evitar reutilizar msg_id durante un período de tiempo muy corto."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/19f4f399091478c95947f6bd7ad61622300c30d9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/35710c6c4a1c64478ec1b5e0e81d386c0844dec6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9d3bf4e9aa23f0d9e99ebe7a94f232ddba54ee17",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/de045a82e1a4e04be62718d3c2981a55150765a0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/19f4f399091478c95947f6bd7ad61622300c30d9",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/35710c6c4a1c64478ec1b5e0e81d386c0844dec6",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/9d3bf4e9aa23f0d9e99ebe7a94f232ddba54ee17",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/de045a82e1a4e04be62718d3c2981a55150765a0",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}