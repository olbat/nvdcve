{
  "id": "CVE-2025-38616",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-08-22T14:15:46.017",
  "lastModified": "2025-08-28T15:15:55.793",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntls: handle data disappearing from under the TLS ULP\n\nTLS expects that it owns the receive queue of the TCP socket.\nThis cannot be guaranteed in case the reader of the TCP socket\nentered before the TLS ULP was installed, or uses some non-standard\nread API (eg. zerocopy ones). Replace the WARN_ON() and a buggy\nearly exit (which leaves anchor pointing to a freed skb) with real\nerror handling. Wipe the parsing state and tell the reader to retry.\n\nWe already reload the anchor every time we (re)acquire the socket lock,\nso the only condition we need to avoid is an out of bounds read\n(not having enough bytes in the socket for previously parsed record len).\n\nIf some data was read from under TLS but there's enough in the queue\nwe'll reload and decrypt what is most likely not a valid TLS record.\nLeading to some undefined behavior from TLS perspective (corrupting\na stream? missing an alert? missing an attack?) but no kernel crash\nshould take place."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tls: gestionar la desaparición de datos bajo el ULP de TLS TLS espera poseer la cola de recepción del socket TCP. Esto no se puede garantizar en caso de que el lector del socket TCP haya entrado antes de que se instalara el ULP de TLS o utilice alguna API de lectura no estándar (p. ej., las de copia cero). Reemplace WARN_ON() y una salida temprana con errores (que deja el ancla apuntando a un skb liberado) con un manejo de errores real. Limpie el estado de análisis y dígale al lector que lo vuelva a intentar. Ya recargamos el ancla cada vez que (re)adquirimos el bloqueo del socket, por lo que la única condición que debemos evitar es una lectura fuera de los límites (no tener suficientes bytes en el socket para la longitud del registro analizado previamente). Si se leyeron algunos datos bajo TLS pero hay suficientes en la cola, recargaremos y descifraremos lo que probablemente no sea un registro TLS válido. Esto genera un comportamiento indefinido desde la perspectiva de TLS (¿corromper una transmisión? ¿perder una alerta? ¿perder un ataque?) pero no debería producirse ninguna falla del kernel."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2fb97ed9e2672b4f6e24ce206ac1a875ce4bcb38",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/6db015fc4b5d5f63a64a193f65d98da3a7fc811d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/db3658a12d5ec4db7185ae7476151a50521b7207",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/eb0336f213fe88bbdb7d2b19c9c9ec19245a3155",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f1fe99919f629f980d0b8a7ff16950bffe06a859",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}