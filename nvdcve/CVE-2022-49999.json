{
  "id": "CVE-2022-49999",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-06-18T11:15:27.673",
  "lastModified": "2025-06-18T13:46:52.973",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix space cache corruption and potential double allocations\n\nWhen testing space_cache v2 on a large set of machines, we encountered a\nfew symptoms:\n\n1. \"unable to add free space :-17\" (EEXIST) errors.\n2. Missing free space info items, sometimes caught with a \"missing free\n   space info for X\" error.\n3. Double-accounted space: ranges that were allocated in the extent tree\n   and also marked as free in the free space tree, ranges that were\n   marked as allocated twice in the extent tree, or ranges that were\n   marked as free twice in the free space tree. If the latter made it\n   onto disk, the next reboot would hit the BUG_ON() in\n   add_new_free_space().\n4. On some hosts with no on-disk corruption or error messages, the\n   in-memory space cache (dumped with drgn) disagreed with the free\n   space tree.\n\nAll of these symptoms have the same underlying cause: a race between\ncaching the free space for a block group and returning free space to the\nin-memory space cache for pinned extents causes us to double-add a free\nrange to the space cache. This race exists when free space is cached\nfrom the free space tree (space_cache=v2) or the extent tree\n(nospace_cache, or space_cache=v1 if the cache needs to be regenerated).\nstruct btrfs_block_group::last_byte_to_unpin and struct\nbtrfs_block_group::progress are supposed to protect against this race,\nbut commit d0c2f4fa555e (\"btrfs: make concurrent fsyncs wait less when\nwaiting for a transaction commit\") subtly broke this by allowing\nmultiple transactions to be unpinning extents at the same time.\n\nSpecifically, the race is as follows:\n\n1. An extent is deleted from an uncached block group in transaction A.\n2. btrfs_commit_transaction() is called for transaction A.\n3. btrfs_run_delayed_refs() -> __btrfs_free_extent() runs the delayed\n   ref for the deleted extent.\n4. __btrfs_free_extent() -> do_free_extent_accounting() ->\n   add_to_free_space_tree() adds the deleted extent back to the free\n   space tree.\n5. do_free_extent_accounting() -> btrfs_update_block_group() ->\n   btrfs_cache_block_group() queues up the block group to get cached.\n   block_group->progress is set to block_group->start.\n6. btrfs_commit_transaction() for transaction A calls\n   switch_commit_roots(). It sets block_group->last_byte_to_unpin to\n   block_group->progress, which is block_group->start because the block\n   group hasn't been cached yet.\n7. The caching thread gets to our block group. Since the commit roots\n   were already switched, load_free_space_tree() sees the deleted extent\n   as free and adds it to the space cache. It finishes caching and sets\n   block_group->progress to U64_MAX.\n8. btrfs_commit_transaction() advances transaction A to\n   TRANS_STATE_SUPER_COMMITTED.\n9. fsync calls btrfs_commit_transaction() for transaction B. Since\n   transaction A is already in TRANS_STATE_SUPER_COMMITTED and the\n   commit is for fsync, it advances.\n10. btrfs_commit_transaction() for transaction B calls\n    switch_commit_roots(). This time, the block group has already been\n    cached, so it sets block_group->last_byte_to_unpin to U64_MAX.\n11. btrfs_commit_transaction() for transaction A calls\n    btrfs_finish_extent_commit(), which calls unpin_extent_range() for\n    the deleted extent. It sees last_byte_to_unpin set to U64_MAX (by\n    transaction B!), so it adds the deleted extent to the space cache\n    again!\n\nThis explains all of our symptoms above:\n\n* If the sequence of events is exactly as described above, when the free\n  space is re-added in step 11, it will fail with EEXIST.\n* If another thread reallocates the deleted extent in between steps 7\n  and 11, then step 11 will silently re-add that space to the space\n  cache as free even though it is actually allocated. Then, if that\n  space is allocated *again*, the free space tree will be corrupted\n  (namely, the wrong item will be deleted).\n* If we don't catch this free space tree corr\n---truncated---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: corrección de corrupción de caché de espacio y posibles asignaciones dobles. Al probar space_cache v2 en un conjunto grande de máquinas, encontramos algunos síntomas: 1. Errores \"no se puede agregar espacio libre :-17\" (EEXIST). 2. Falta de información de espacio libre, a veces detectados con el error \"falta información de espacio libre para X\". 3. Espacio contabilizado dos veces: rangos asignados en el árbol de extensiones y marcados como libres en dicho árbol, rangos marcados como asignados dos veces en el árbol de extensiones o rangos marcados como libres dos veces en dicho árbol. Si estos últimos se almacenaban en el disco, el siguiente reinicio generaría el error BUG_ON() en add_new_free_space(). 4. En algunos hosts sin corrupción en disco ni mensajes de error, la caché de espacio en memoria (volcada con drgn) no coincidía con el árbol de espacio libre. Todos estos síntomas tienen la misma causa subyacente: una competencia entre el almacenamiento en caché del espacio libre de un grupo de bloques y su devolución a la caché de espacio en memoria para las extensiones fijadas provoca la duplicación de un rango libre en la caché de espacio. Esta competencia se produce cuando se almacena en caché el espacio libre del árbol de espacio libre (space_cache=v2) o del árbol de extensiones (nospace_cache, o space_cache=v1 si es necesario regenerar la caché). Se supone que struct btrfs_block_group::last_byte_to_unpin y struct btrfs_block_group::progress protegen contra esta competencia, pero el commit d0c2f4fa555e (\"btrfs: hacer que las sincronizaciones simultáneas esperen menos al esperar el commit de una transacción\") interrumpió esto sutilmente al permitir que varias transacciones desanclaran extensiones simultáneamente. Específicamente, la ejecución es la siguiente: 1. Se elimina una extensión de un grupo de bloques no almacenados en caché en la transacción A. 2. Se llama a btrfs_commit_transaction() para la transacción A. 3. btrfs_run_delayed_refs() -&gt; __btrfs_free_extent() ejecuta la referencia retrasada para la extensión eliminada. 4. __btrfs_free_extent() -&gt; do_free_extent_accounting() -&gt; add_to_free_space_tree() agrega la extensión eliminada nuevamente al árbol de espacio libre. 5. do_free_extent_accounting() -&gt; btrfs_update_block_group() -&gt; btrfs_cache_block_group() pone en cola el grupo de bloques para almacenar en caché. block_group-&gt;progress se establece en block_group-&gt;start. 6. btrfs_commit_transaction() para la transacción A llama a switch_commit_roots(). Establece block_group-&gt;last_byte_to_unpin en block_group-&gt;progress, que es block_group-&gt;start porque el grupo de bloques aún no se ha almacenado en caché. 7. El hilo de caché accede a nuestro grupo de bloques. Dado que las raíces de las confirmaciones ya se han cambiado, load_free_space_tree() detecta la extensión eliminada como libre y la añade a la caché de espacio. Finaliza el almacenamiento en caché y establece block_group-&gt;progress en U64_MAX. 8. btrfs_commit_transaction() avanza la transacción A a TRANS_STATE_SUPER_COMMITTED. 9. fsync llama a btrfs_commit_transaction() para la transacción B. Dado que la transacción A ya está en TRANS_STATE_SUPER_COMMITTED y el commit es para fsync, avanza. 10. btrfs_commit_transaction() para la transacción B llama a switch_commit_roots(). Esta vez, el grupo de bloques ya se ha almacenado en caché, por lo que establece block_group-&gt;last_byte_to_unpin en U64_MAX. 11. btrfs_commit_transaction() para la transacción A llama a btrfs_finish_extent_commit(), que llama a unpin_extent_range() para la extensión eliminada. Ve que last_byte_to_unpin está establecido en U64_MAX (¡por la transacción B!), por lo que vuelve a añadir la extensión eliminada a la caché de espacio. Esto explica todos nuestros síntomas anteriores: * Si la secuencia de eventos es exactamente la descrita anteriormente, cuando se vuelve a añadir el espacio libre en el paso 11, fallará con EEXIST. * ---truncado---"
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/92dc4c1a8e58bcc7a183a4c86b055c24cc88d967",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a2e54eb64229f07f917b05d0c323604fda9b89f7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ced8ecf026fd8084cf175530ff85c76d6085d715",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}