{
  "id": "CVE-2024-27415",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-17T12:15:12.867",
  "lastModified": "2024-11-21T09:04:34.623",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: bridge: confirm multicast packets before passing them up the stack\n\nconntrack nf_confirm logic cannot handle cloned skbs referencing\nthe same nf_conn entry, which will happen for multicast (broadcast)\nframes on bridges.\n\n Example:\n    macvlan0\n       |\n      br0\n     /  \\\n  ethX    ethY\n\n ethX (or Y) receives a L2 multicast or broadcast packet containing\n an IP packet, flow is not yet in conntrack table.\n\n 1. skb passes through bridge and fake-ip (br_netfilter)Prerouting.\n    -> skb->_nfct now references a unconfirmed entry\n 2. skb is broad/mcast packet. bridge now passes clones out on each bridge\n    interface.\n 3. skb gets passed up the stack.\n 4. In macvlan case, macvlan driver retains clone(s) of the mcast skb\n    and schedules a work queue to send them out on the lower devices.\n\n    The clone skb->_nfct is not a copy, it is the same entry as the\n    original skb.  The macvlan rx handler then returns RX_HANDLER_PASS.\n 5. Normal conntrack hooks (in NF_INET_LOCAL_IN) confirm the orig skb.\n\nThe Macvlan broadcast worker and normal confirm path will race.\n\nThis race will not happen if step 2 already confirmed a clone. In that\ncase later steps perform skb_clone() with skb->_nfct already confirmed (in\nhash table).  This works fine.\n\nBut such confirmation won't happen when eb/ip/nftables rules dropped the\npackets before they reached the nf_confirm step in postrouting.\n\nPablo points out that nf_conntrack_bridge doesn't allow use of stateful\nnat, so we can safely discard the nf_conn entry and let inet call\nconntrack again.\n\nThis doesn't work for bridge netfilter: skb could have a nat\ntransformation. Also bridge nf prevents re-invocation of inet prerouting\nvia 'sabotage_in' hook.\n\nWork around this problem by explicit confirmation of the entry at LOCAL_IN\ntime, before upper layer has a chance to clone the unconfirmed entry.\n\nThe downside is that this disables NAT and conntrack helpers.\n\nAlternative fix would be to add locking to all code parts that deal with\nunconfirmed packets, but even if that could be done in a sane way this\nopens up other problems, for example:\n\n-m physdev --physdev-out eth0 -j SNAT --snat-to 1.2.3.4\n-m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5\n\nFor multicast case, only one of such conflicting mappings will be\ncreated, conntrack only handles 1:1 NAT mappings.\n\nUsers should set create a setup that explicitly marks such traffic\nNOTRACK (conntrack bypass) to avoid this, but we cannot auto-bypass\nthem, ruleset might have accept rules for untracked traffic already,\nso user-visible behaviour would change."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: netfilter: bridge: confirme los paquetes de multidifusión antes de pasarlos a la pila conntrack La lógica nf_confirm no puede manejar skbs clonados que hagan referencia a la misma entrada nf_conn, lo que sucederá con las tramas de multidifusión (difusión) en puentes. Ejemplo: macvlan0 | br0 / \\ ethX ethY ethX (o Y) recibe un paquete de multidifusión o difusión L2 que contiene un paquete IP, el flujo aún no está en la tabla conntrack. 1. skb pasa por el puente y el enrutamiento previo de IP falsa (br_netfilter). -&gt; skb-&gt;_nfct ahora hace referencia a una entrada no confirmada 2. skb es un paquete amplio/mcast. El puente ahora pasa clones en cada interfaz del puente. 3. skb pasa a la pila. 4. En el caso de macvlan, el controlador macvlan conserva los clones del skb mcast y programa una cola de trabajo para enviarlos a los dispositivos inferiores. El clon skb-&gt;_nfct no es una copia, es la misma entrada que el skb original. El controlador macvlan rx luego devuelve RX_HANDLER_PASS. 5. Los ganchos de conexión normales (en NF_INET_LOCAL_IN) confirman el skb original. El trabajador de transmisión de Macvlan y la ruta de confirmación normal correrán. Esta carrera no se realizará si el paso 2 ya confirmó un clon. En ese caso, los pasos posteriores realizan skb_clone() con skb-&gt;_nfct ya confirmado (en la tabla hash). Esto funciona bien. Pero dicha confirmación no ocurrirá cuando las reglas eb/ip/nftables eliminen los paquetes antes de que alcancen el paso nf_confirm en el posenrutamiento. Pablo señala que nf_conntrack_bridge no permite el uso de nat con estado, por lo que podemos descartar con seguridad la entrada nf_conn y dejar que inet llame a conntrack nuevamente. Esto no funciona para bridge netfilter: skb podría tener una transformación nat. Además, bridge nf evita la reinvocación del enrutamiento previo de inet a través del gancho 'sabotage_in'. Evite este problema confirmando explícitamente la entrada en el momento LOCAL_IN, antes de que la capa superior tenga la oportunidad de clonar la entrada no confirmada. La desventaja es que esto desactiva NAT y los asistentes de conexión. Una solución alternativa sería agregar bloqueo a todas las partes del código que tratan con paquetes no confirmados, pero incluso si eso pudiera hacerse de manera sensata, esto abre otros problemas, por ejemplo: -m physdev --physdev-out eth0 -j SNAT - -snat-to 1.2.3.4 -m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5 Para el caso de multidifusión, solo se creará una de estas asignaciones conflictivas, conntrack solo maneja asignaciones NAT 1:1. Los usuarios deben crear una configuración que marque explícitamente dicho tráfico NOTRACK (omisión de conntrack) para evitar esto, pero no podemos omitirlos automáticamente, es posible que el conjunto de reglas ya haya aceptado reglas para el tráfico sin seguimiento, por lo que el comportamiento visible para el usuario cambiaría."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2b1414d5e94e477edff1d2c79030f1d742625ea0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/62e7151ae3eb465e0ab52a20c941ff33bb6332e9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7c3f28599652acf431a2211168de4a583f30b6d5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/80cd0487f630b5382734997c3e5e3003a77db315",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/cb734975b0ffa688ff6cc0eed463865bf07b6c01",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2b1414d5e94e477edff1d2c79030f1d742625ea0",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/62e7151ae3eb465e0ab52a20c941ff33bb6332e9",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/7c3f28599652acf431a2211168de4a583f30b6d5",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/80cd0487f630b5382734997c3e5e3003a77db315",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/cb734975b0ffa688ff6cc0eed463865bf07b6c01",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}