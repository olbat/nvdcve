{
  "cve": {
    "data_type": "CVE",
    "data_format": "MITRE",
    "data_version": "4.0",
    "CVE_data_meta": {
      "ID": "CVE-2018-10470",
      "ASSIGNER": "cve@mitre.org"
    },
    "affects": {
      "vendor": {
        "vendor_data": [

        ]
      }
    },
    "problemtype": {
      "problemtype_data": [
        {
          "description": [

          ]
        }
      ]
    },
    "references": {
      "reference_data": [
        {
          "url": "https://obdev.at/cve/2018-10470-8FRWkW4oH8.html",
          "name": "https://obdev.at/cve/2018-10470-8FRWkW4oH8.html",
          "refsource": "CONFIRM",
          "tags": [

          ]
        },
        {
          "url": "https://www.okta.com/security-blog/2018/06/issues-around-third-party-apple-code-signing-checks/",
          "name": "https://www.okta.com/security-blog/2018/06/issues-around-third-party-apple-code-signing-checks/",
          "refsource": "MISC",
          "tags": [

          ]
        }
      ]
    },
    "description": {
      "description_data": [
        {
          "lang": "en",
          "value": "Little Snitch versions 4.0 to 4.0.6 use the SecStaticCodeCheckValidityWithErrors() function without the kSecCSCheckAllArchitectures flag and therefore do not validate all architectures stored in a fat binary. An attacker can maliciously craft a fat binary containing multiple architectures that may cause a situation where Little Snitch treats the running process as having no code signature at all while erroneously indicating that the binary on disk does have a valid code signature. This could lead to users being confused about whether or not the code signature is valid."
        }
      ]
    }
  },
  "configurations": {
    "CVE_data_version": "4.0",
    "nodes": [

    ]
  },
  "impact": {
  },
  "publishedDate": "2018-06-12T17:29Z",
  "lastModifiedDate": "2018-06-13T01:29Z"
}