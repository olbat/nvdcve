{
  "id": "CVE-2025-38321",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-10T09:15:26.103",
  "lastModified": "2025-07-10T13:17:30.017",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: Log an error when close_all_cached_dirs fails\n\nUnder low-memory conditions, close_all_cached_dirs() can't move the\ndentries to a separate list to dput() them once the locks are dropped.\nThis will result in a \"Dentry still in use\" error, so add an error\nmessage that makes it clear this is what happened:\n\n[  495.281119] CIFS: VFS: \\\\otters.example.com\\share Out of memory while dropping dentries\n[  495.281595] ------------[ cut here ]------------\n[  495.281887] BUG: Dentry ffff888115531138{i=78,n=/}  still in use (2) [unmount of cifs cifs]\n[  495.282391] WARNING: CPU: 1 PID: 2329 at fs/dcache.c:1536 umount_check+0xc8/0xf0\n\nAlso, bail out of looping through all tcons as soon as a single\nallocation fails, since we're already in trouble, and kmalloc() attempts\nfor subseqeuent tcons are likely to fail just like the first one did."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: smb: Registra un error cuando close_all_cached_dirs falla. En condiciones de poca memoria, close_all_cached_dirs() no puede mover las entradas a una lista separada para dput() una vez que se eliminan los bloqueos. Esto generará un error \"Dentry aún en uso\", por lo que debe agregar un mensaje de error que aclare que esto es lo que sucedió: [ 495.281119] CIFS: VFS: \\\\otters.example.com\\share Sin memoria al eliminar dentries [ 495.281595] ------------[ cortar aquí ]------------ [ 495.281887] ERROR: Dentry ffff888115531138{i=78,n=/} aún en uso (2) [desmontar cifs cifs] [ 495.282391] ADVERTENCIA: CPU: 1 PID: 2329 en fs/dcache.c:1536 umount_check+0xc8/0xf0 Además, abandone el bucle a través de todos los tcons tan pronto como falle una sola asignación, ya que estamos en problemas y kmalloc() intenta Es probable que las tcons subsiguientes fallen tal como lo hizo la primera."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/43f26094d6702e494e800532c3f1606e7a68eb30",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4479db143390bdcadc1561292aab579cdfa9f6c6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a2182743a8b4969481f64aec4908ff162e8a206c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b8ced2b9a23a1a2c1e0ed8d0d02512e51bdf38da",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}