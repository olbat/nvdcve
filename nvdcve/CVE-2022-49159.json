{
  "id": "CVE-2022-49159",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:00:53.103",
  "lastModified": "2025-02-26T07:00:53.103",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Implement ref count for SRB\n\nThe timeout handler and the done function are racing. When\nqla2x00_async_iocb_timeout() starts to run it can be preempted by the\nnormal response path (via the firmware?). qla24xx_async_gpsc_sp_done()\nreleases the SRB unconditionally. When scheduling back to\nqla2x00_async_iocb_timeout() qla24xx_async_abort_cmd() will access an freed\nsp->qpair pointer:\n\n  qla2xxx [0000:83:00.0]-2871:0: Async-gpsc timeout - hdl=63d portid=234500 50:06:0e:80:08:77:b6:21.\n  qla2xxx [0000:83:00.0]-2853:0: Async done-gpsc res 0, WWPN 50:06:0e:80:08:77:b6:21\n  qla2xxx [0000:83:00.0]-2854:0: Async-gpsc OUT WWPN 20:45:00:27:f8:75:33:00 speeds=2c00 speed=0400.\n  qla2xxx [0000:83:00.0]-28d8:0: qla24xx_handle_gpsc_event 50:06:0e:80:08:77:b6:21 DS 7 LS 6 rc 0 login 1|1 rscn 1|0 lid 5\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000004\n  IP: qla24xx_async_abort_cmd+0x1b/0x1c0 [qla2xxx]\n\nObvious solution to this is to introduce a reference counter. One reference\nis taken for the normal code path (the 'good' case) and one for the timeout\npath. As we always race between the normal good case and the timeout/abort\nhandler we need to serialize it. Also we cannot assume any order between\nthe handlers. Since this is slow path we can use proper synchronization via\nlocks.\n\nWhen we are able to cancel a timer (del_timer returns 1) we know there\ncan't be any error handling in progress because the timeout handler hasn't\nexpired yet, thus we can safely decrement the refcounter by one.\n\nIf we are not able to cancel the timer, we know an abort handler is\nrunning. We have to make sure we call sp->done() in the abort handlers\nbefore calling kref_put()."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: qla2xxx: Implementar recuento de referencias para SRB El controlador de tiempo de espera y la función done están en ejecución. Cuando qla2x00_async_iocb_timeout() comienza a ejecutarse, puede ser interrumpido por la ruta de respuesta normal (¿a través del firmware?). qla24xx_async_gpsc_sp_done() libera el SRB incondicionalmente. Al programar de nuevo a qla2x00_async_iocb_timeout(), qla24xx_async_abort_cmd() accederá a un puntero sp-&gt;qpair liberado: qla2xxx [0000:83:00.0]-2871:0: Tiempo de espera de Async-gpsc - hdl=63d portid=234500 50:06:0e:80:08:77:b6:21. qla2xxx [0000:83:00.0]-2853:0: Async-gpsc res 0, WWPN 50:06:0e:80:08:77:b6:21 qla2xxx [0000:83:00.0]-2854:0: Async-gpsc SALIDA WWPN 20:45:00:27:f8:75:33:00 velocidades=2c00 velocidad=0400. qla2xxx [0000:83:00.0]-28d8:0: qla24xx_handle_gpsc_event 50:06:0e:80:08:77:b6:21 DS 7 LS 6 rc 0 login 1|1 rscn 1|0 lid 5 ERROR: no se puede manejar la desreferencia del puntero NULL del núcleo en 0000000000000004 IP: qla24xx_async_abort_cmd+0x1b/0x1c0 [qla2xxx] La solución obvia para esto es introducir un contador de referencia. Se toma una referencia para la ruta de código normal (el caso \"bueno\") y otra para la ruta de tiempo de espera. Como siempre corremos entre el caso bueno normal y el controlador de tiempo de espera/aborto, necesitamos serializarlo. Además, no podemos asumir ningún orden entre los controladores. Dado que esta es una ruta lenta, podemos usar la sincronización adecuada a través de bloqueos. Cuando podemos cancelar un temporizador (del_timer devuelve 1), sabemos que no puede haber ningún manejo de errores en curso porque el manejador de tiempo de espera aún no ha expirado, por lo que podemos disminuir de manera segura el contador de referencias en uno. Si no podemos cancelar el temporizador, sabemos que se está ejecutando un manejador de aborto. Tenemos que asegurarnos de llamar a sp-&gt;done() en los manejadores de aborto antes de llamar a kref_put()."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/31e6cdbe0eae37badceb5e0d4f06cf051432fd77",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ceda7f794f3dfe272491e93e3e93049f8be5f07b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e140723f78ff418c8df7d990e102e07b65c87d4a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e17111dd2fda81c35f309b1e5b6ab35809a375e7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}