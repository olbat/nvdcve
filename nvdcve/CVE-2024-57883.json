{
  "id": "CVE-2024-57883",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-01-15T13:15:12.637",
  "lastModified": "2025-06-27T11:15:23.907",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: hugetlb: independent PMD page table shared count\n\nThe folio refcount may be increased unexpectly through try_get_folio() by\ncaller such as split_huge_pages.  In huge_pmd_unshare(), we use refcount\nto check whether a pmd page table is shared.  The check is incorrect if\nthe refcount is increased by the above caller, and this can cause the page\ntable leaked:\n\n BUG: Bad page state in process sh  pfn:109324\n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x66 pfn:0x109324\n flags: 0x17ffff800000000(node=0|zone=2|lastcpupid=0xfffff)\n page_type: f2(table)\n raw: 017ffff800000000 0000000000000000 0000000000000000 0000000000000000\n raw: 0000000000000066 0000000000000000 00000000f2000000 0000000000000000\n page dumped because: nonzero mapcount\n ...\n CPU: 31 UID: 0 PID: 7515 Comm: sh Kdump: loaded Tainted: G    B              6.13.0-rc2master+ #7\n Tainted: [B]=BAD_PAGE\n Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015\n Call trace:\n  show_stack+0x20/0x38 (C)\n  dump_stack_lvl+0x80/0xf8\n  dump_stack+0x18/0x28\n  bad_page+0x8c/0x130\n  free_page_is_bad_report+0xa4/0xb0\n  free_unref_page+0x3cc/0x620\n  __folio_put+0xf4/0x158\n  split_huge_pages_all+0x1e0/0x3e8\n  split_huge_pages_write+0x25c/0x2d8\n  full_proxy_write+0x64/0xd8\n  vfs_write+0xcc/0x280\n  ksys_write+0x70/0x110\n  __arm64_sys_write+0x24/0x38\n  invoke_syscall+0x50/0x120\n  el0_svc_common.constprop.0+0xc8/0xf0\n  do_el0_svc+0x24/0x38\n  el0_svc+0x34/0x128\n  el0t_64_sync_handler+0xc8/0xd0\n  el0t_64_sync+0x190/0x198\n\nThe issue may be triggered by damon, offline_page, page_idle, etc, which\nwill increase the refcount of page table.\n\n1. The page table itself will be discarded after reporting the\n   \"nonzero mapcount\".\n\n2. The HugeTLB page mapped by the page table miss freeing since we\n   treat the page table as shared and a shared page table will not be\n   unmapped.\n\nFix it by introducing independent PMD page table shared count.  As\ndescribed by comment, pt_index/pt_mm/pt_frag_refcount are used for s390\ngmap, x86 pgds and powerpc, pt_share_count is used for x86/arm64/riscv\npmds, so we can reuse the field as pt_share_count."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: hugetlb: recuento compartido de la tabla de páginas PMD independiente El recuento de referencias de folio puede aumentar inesperadamente a través de try_get_folio() por un llamador como split_huge_pages. En huge_pmd_unshare(), usamos el recuento de referencias para verificar si una tabla de páginas pmd está compartida. La comprobación es incorrecta si el llamador anterior aumenta el refcount, y esto puede provocar una fuga de la tabla de páginas: ERROR: Estado de página incorrecto en proceso sh pfn:109324 página: refcount:0 mapcount:0 mapping:0000000000000000 índice:0x66 pfn:0x109324 indicadores: 0x17ffff800000000(nodo=0|zona=2|lastcpupid=0xfffff) tipo_página: f2(tabla) sin procesar: 017ffff800000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 sin procesar: 0000000000000066 0000000000000000 00000000f2000000 0000000000000000 página volcada porque: mapcount distinto de cero ... CPU: 31 UID: 0 PID: 7515 Comm: sh Kdump: cargado Contaminado: GB 6.13.0-rc2master+ #7 Contaminado: [B]=BAD_PAGE Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015 Call trace: show_stack+0x20/0x38 (C) dump_stack_lvl+0x80/0xf8 dump_stack+0x18/0x28 bad_page+0x8c/0x130 free_page_is_bad_report+0xa4/0xb0 free_unref_page+0x3cc/0x620 __folio_put+0xf4/0x158 split_huge_pages_all+0x1e0/0x3e8 split_huge_pages_write+0x25c/0x2d8 full_proxy_write+0x64/0xd8 vfs_write+0xcc/0x280 ksys_write+0x70/0x110 __arm64_sys_write+0x24/0x38 invoke_syscall+0x50/0x120 el0_svc_common.constprop.0+0xc8/0xf0 do_el0_svc+0x24/0x38 el0_svc+0x34/0x128 el0t_64_sync_handler+0xc8/0xd0 el0t_64_sync+0x190/0x198 El problema puede ser provocado por damon, offline_page, page_idle, etc., que aumentarán el recuento de referencias de la tabla de páginas. 1. La tabla de páginas en sí se descartará después de informar el \"recuento de mapas distinto de cero\". 2. La página HugeTLB mapeada por la tabla de páginas no se libera ya que tratamos la tabla de páginas como compartida y una tabla de páginas compartida no se desasignará. Arréglelo introduciendo un recuento de páginas compartidas de tabla de páginas PMD independiente. Como se describe en el comentario, pt_index/pt_mm/pt_frag_refcount se utilizan para s390 gmap, x86 pgds y powerpc, pt_share_count se utiliza para x86/arm64/riscv pmds, por lo que podemos reutilizar el campo como pt_share_count."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/02333ac1c35370517a19a4a131332a9690c6a5c7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2e31443a0d18ae43b9d29e02bf0563f07772193d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/56b274473d6e7e7375f2d0a2b4aca11d67c6b52f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/59d9094df3d79443937add8700b2ef1a866b1081",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8410996eb6fea116fe1483ed977aacf580eee7b4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/94b4b41d0cdf5cfd4d4325bc0e6e9e0d0e996133",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}