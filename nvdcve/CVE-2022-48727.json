{
  "id": "CVE-2022-48727",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-06-20T12:15:11.167",
  "lastModified": "2024-11-21T07:33:52.460",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: Avoid consuming a stale esr value when SError occur\n\nWhen any exception other than an IRQ occurs, the CPU updates the ESR_EL2\nregister with the exception syndrome. An SError may also become pending,\nand will be synchronised by KVM. KVM notes the exception type, and whether\nan SError was synchronised in exit_code.\n\nWhen an exception other than an IRQ occurs, fixup_guest_exit() updates\nvcpu->arch.fault.esr_el2 from the hardware register. When an SError was\nsynchronised, the vcpu esr value is used to determine if the exception\nwas due to an HVC. If so, ELR_EL2 is moved back one instruction. This\nis so that KVM can process the SError first, and re-execute the HVC if\nthe guest survives the SError.\n\nBut if an IRQ synchronises an SError, the vcpu's esr value is stale.\nIf the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,\ncausing an unrelated guest instruction to be executed twice.\n\nCheck ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don't\nupdate this register so don't need to check."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: KVM: arm64: Evite consumir un valor esr obsoleto cuando ocurre un SError Cuando ocurre cualquier excepción que no sea una IRQ, la CPU actualiza el registro ESR_EL2 con el síndrome de excepción. Un SError también puede quedar pendiente y KVM lo sincronizará. KVM anota el tipo de excepción y si se sincronizó un SError en exit_code. Cuando ocurre una excepción distinta a una IRQ, fixup_guest_exit() actualiza vcpu-&gt;arch.fault.esr_el2 desde el registro de hardware. Cuando se sincroniza un SError, el valor de vcpu esr se utiliza para determinar si la excepción se debió a un HVC. Si es así, ELR_EL2 retrocede una instrucción. Esto es para que KVM pueda procesar el SError primero y volver a ejecutar el HVC si el invitado sobrevive al SError. Pero si una IRQ sincroniza un SError, el valor esr de la vcpu está obsoleto. Si la excepción anterior no IRQ era un HVC, KVM dañará ELR_EL2, lo que provocará que se ejecute dos veces una instrucción invitada no relacionada. Verifique ARM_EXCEPTION_CODE() antes de jugar con ELR_EL2, las IRQ no actualizan este registro, por lo que no es necesario verificarlo."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}