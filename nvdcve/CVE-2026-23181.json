{
  "id": "CVE-2026-23181",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T17:15:55.853",
  "lastModified": "2026-02-18T17:52:22.253",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: sync read disk super and set block size\n\nWhen the user performs a btrfs mount, the block device is not set\ncorrectly. The user sets the block size of the block device to 0x4000\nby executing the BLKBSZSET command.\nSince the block size change also changes the mapping->flags value, this\nfurther affects the result of the mapping_min_folio_order() calculation.\n\nLet's analyze the following two scenarios:\n\nScenario 1: Without executing the BLKBSZSET command, the block size is\n0x1000, and mapping_min_folio_order() returns 0;\n\nScenario 2: After executing the BLKBSZSET command, the block size is\n0x4000, and mapping_min_folio_order() returns 2.\n\ndo_read_cache_folio() allocates a folio before the BLKBSZSET command\nis executed. This results in the allocated folio having an order value\nof 0. Later, after BLKBSZSET is executed, the block size increases to\n0x4000, and the mapping_min_folio_order() calculation result becomes 2.\n\nThis leads to two undesirable consequences:\n\n1. filemap_add_folio() triggers a VM_BUG_ON_FOLIO(folio_order(folio) <\nmapping_min_folio_order(mapping)) assertion.\n\n2. The syzbot report [1] shows a null pointer dereference in\ncreate_empty_buffers() due to a buffer head allocation failure.\n\nSynchronization should be established based on the inode between the\nBLKBSZSET command and read cache page to prevent inconsistencies in\nblock size or mapping flags before and after folio allocation.\n\n[1]\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nRIP: 0010:create_empty_buffers+0x4d/0x480 fs/buffer.c:1694\nCall Trace:\n folio_create_buffers+0x109/0x150 fs/buffer.c:1802\n block_read_full_folio+0x14c/0x850 fs/buffer.c:2403\n filemap_read_folio+0xc8/0x2a0 mm/filemap.c:2496\n do_read_cache_folio+0x266/0x5c0 mm/filemap.c:4096\n do_read_cache_page mm/filemap.c:4162 [inline]\n read_cache_page_gfp+0x29/0x120 mm/filemap.c:4195\n btrfs_read_disk_super+0x192/0x500 fs/btrfs/volumes.c:1367"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nbtrfs: sincronizar la lectura del superbloque del disco y establecer el tamaño de bloque\n\nCuando el usuario realiza un montaje btrfs, el dispositivo de bloques no se configura correctamente. El usuario establece el tamaño de bloque del dispositivo de bloques a 0x4000 ejecutando el comando BLKBSZSET.\nDado que el cambio de tamaño de bloque también modifica el valor de mapping-&gt;flags, esto afecta aún más el resultado del cálculo de mapping_min_folio_order().\n\nAnalicemos los dos escenarios siguientes:\n\nEscenario 1: Sin ejecutar el comando BLKBSZSET, el tamaño de bloque es 0x1000, y mapping_min_folio_order() devuelve 0;\n\nEscenario 2: Después de ejecutar el comando BLKBSZSET, el tamaño de bloque es 0x4000, y mapping_min_folio_order() devuelve 2.\n\ndo_read_cache_folio() asigna un folio antes de que se ejecute el comando BLKBSZSET. Esto resulta en que el folio asignado tiene un valor de orden de 0. Posteriormente, después de ejecutar BLKBSZSET, el tamaño de bloque aumenta a 0x4000, y el resultado del cálculo de mapping_min_folio_order() se convierte en 2.\n\nEsto conduce a dos consecuencias indeseables:\n\n1. filemap_add_folio() activa una aserción VM_BUG_ON_FOLIO(folio_order(folio) &lt; mapping_min_folio_order(mapping)).\n\n2. El informe de syzbot [1] muestra una desreferencia de puntero nulo en create_empty_buffers() debido a un fallo en la asignación de un buffer head.\n\nSe debe establecer una sincronización basada en el inodo entre el comando BLKBSZSET y la página de caché de lectura para evitar inconsistencias en el tamaño de bloque o las banderas de mapeo antes y después de la asignación de folio.\n\n[1]\nKASAN: desreferencia de puntero nulo en el rango [0x0000000000000000-0x0000000000000007]\nRIP: 0010:create_empty_buffers+0x4d/0x480 fs/buffer.c:1694\nRastro de Llamada:\n folio_create_buffers+0x109/0x150 fs/buffer.c:1802\n block_read_full_folio+0x14c/0x850 fs/buffer.c:2403\n filemap_read_folio+0xc8/0x2a0 mm/filemap.c:2496\n do_read_cache_folio+0x266/0x5c0 mm/filemap.c:4096\n do_read_cache_page mm/filemap.c:4162 [inline]\n read_cache_page_gfp+0x29/0x120 mm/filemap.c:4195\n btrfs_read_disk_super+0x192/0x500 fs/btrfs/volumes.c:1367"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/3f29d661e5686f3aa14e6f11537ff5c49846f2e2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ccb3c75d57039adb3170ae54a0d470e359705984",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}