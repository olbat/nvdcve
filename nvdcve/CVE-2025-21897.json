{
  "id": "CVE-2025-21897",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-01T16:15:20.083",
  "lastModified": "2025-04-01T20:26:01.990",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched_ext: Fix pick_task_scx() picking non-queued tasks when it's called without balance()\n\na6250aa251ea (\"sched_ext: Handle cases where pick_task_scx() is called\nwithout preceding balance_scx()\") added a workaround to handle the cases\nwhere pick_task_scx() is called without prececing balance_scx() which is due\nto a fair class bug where pick_taks_fair() may return NULL after a true\nreturn from balance_fair().\n\nThe workaround detects when pick_task_scx() is called without preceding\nbalance_scx() and emulates SCX_RQ_BAL_KEEP and triggers kicking to avoid\nstalling. Unfortunately, the workaround code was testing whether @prev was\non SCX to decide whether to keep the task running. This is incorrect as the\ntask may be on SCX but no longer runnable.\n\nThis could lead to a non-runnable task to be returned from pick_task_scx()\nwhich cause interesting confusions and failures. e.g. A common failure mode\nis the task ending up with (!on_rq && on_cpu) state which can cause\npotential wakers to busy loop, which can easily lead to deadlocks.\n\nFix it by testing whether @prev has SCX_TASK_QUEUED set. This makes\n@prev_on_scx only used in one place. Open code the usage and improve the\ncomment while at it."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: sched_ext: Fix pick_task_scx() picking nonqueued task when it is called without balance() a6250aa251ea (\"sched_ext: Handle cases where pick_task_scx() is called without previous balance_scx()\") añadió un workaround para gestionar los casos donde pick_task_scx() se llama sin preceder a balance_scx(), lo cual se debe a un error de clase fair donde pick_taks_fair() puede devolver NULL después de un retorno verdadero de balance_fair(). El workaround detecta cuándo se llama a pick_task_scx() sin preceder a balance_scx() y emula SCX_RQ_BAL_KEEP y activa el kicking para evitar el estancamiento. Desafortunadamente, el código del workaround estaba probando si @prev estaba en SCX para decidir si mantener la tarea en ejecución. Esto es incorrecto ya que la tarea puede estar en SCX pero ya no se puede ejecutar. Esto podría provocar que pick_task_scx() devuelva una tarea no ejecutable, lo que causa confusiones y fallos interesantes. Por ejemplo, un modo de fallo común es que la tarea termine en el estado (!on_rq &amp;&amp; on_cpu), lo que puede provocar que los posibles reactivadores entren en bucles de ocupación, lo que puede fácilmente provocar interbloqueos. Solucione esto comprobando si @prev tiene SCX_TASK_QUEUED definido. Esto hace que @prev_on_scx solo se use en un lugar. Abra el código para su uso y mejore el comentario."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/5324c459f90d16b0c43a78b494c598915d782b7a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8fef0a3b17bb258130a4fcbcb5addf94b25e9ec5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/de60a31cb0bcacfaf9487546eac5e70e0a9c66d7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}