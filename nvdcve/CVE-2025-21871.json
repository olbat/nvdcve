{
  "id": "CVE-2025-21871",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-03-27T14:15:48.860",
  "lastModified": "2025-03-27T16:45:12.210",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntee: optee: Fix supplicant wait loop\n\nOP-TEE supplicant is a user-space daemon and it's possible for it\nbe hung or crashed or killed in the middle of processing an OP-TEE\nRPC call. It becomes more complicated when there is incorrect shutdown\nordering of the supplicant process vs the OP-TEE client application which\ncan eventually lead to system hang-up waiting for the closure of the\nclient application.\n\nAllow the client process waiting in kernel for supplicant response to\nbe killed rather than indefinitely waiting in an unkillable state. Also,\na normal uninterruptible wait should not have resulted in the hung-task\nwatchdog getting triggered, but the endless loop would.\n\nThis fixes issues observed during system reboot/shutdown when supplicant\ngot hung for some reason or gets crashed/killed which lead to client\ngetting hung in an unkillable state. It in turn lead to system being in\nhung up state requiring hard power off/on to recover."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tee: optee: Fix supplicant wait loop OP-TEE supplicant es un daemon de espacio de usuario y es posible que se cuelgue, se bloquee o se elimine en medio del procesamiento de una llamada RPC OP-TEE. Se vuelve más complicado cuando hay un orden de apagado incorrecto del proceso suplicante frente a la aplicación cliente OP-TEE, lo que puede eventualmente provocar que el sistema se cuelgue esperando el cierre de la aplicación cliente. Permita que el proceso cliente que espera en el kernel la respuesta del suplicante se elimine en lugar de esperar indefinidamente en un estado imposible de eliminar. Además, una espera ininterrumpida normal no debería haber provocado que se activara el watchdog de tareas colgadas, pero el bucle infinito sí. Esto soluciona los problemas observados durante el reinicio/apagado del sistema cuando el suplicante se colgaba por alguna razón o se bloqueaba/eliminaba, lo que provocaba que el cliente se colgara en un estado imposible de eliminar. A su vez, provocaba que el sistema quedara en un estado colgado que requería un apagado/encendido forzado para recuperarse."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0180cf0373f84fff61b16f8c062553a13dd7cfca",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/21234efe2a8474a6d2d01ea9573319de7858ce44",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3eb4911364c764572e9db4ab900a57689a54e8ce",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/70b0d6b0a199c5a3ee6c72f5e61681ed6f759612",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c0a9a948159153be145f9471435695373904ee6d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d61cc1a435e6894bfb0dd3370c6f765d2d12825d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ec18520f5edc20a00c34a8c9fdd6507c355e880f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/fd9d2d6124c293e40797a080adf8a9c237efd8b8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}