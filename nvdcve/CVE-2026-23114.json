{
  "id": "CVE-2026-23114",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T15:16:06.500",
  "lastModified": "2026-02-18T17:52:44.520",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/fpsimd: ptrace: Fix SVE writes on !SME systems\n\nWhen SVE is supported but SME is not supported, a ptrace write to the\nNT_ARM_SVE regset can place the tracee into an invalid state where\n(non-streaming) SVE register data is stored in FP_STATE_SVE format but\nTIF_SVE is clear. This can result in a later warning from\nfpsimd_restore_current_state(), e.g.\n\n  WARNING: CPU: 0 PID: 7214 at arch/arm64/kernel/fpsimd.c:383 fpsimd_restore_current_state+0x50c/0x748\n\nWhen this happens, fpsimd_restore_current_state() will set TIF_SVE,\nplacing the task into the correct state. This occurs before any other\ncheck of TIF_SVE can possibly occur, as other checks of TIF_SVE only\nhappen while the FPSIMD/SVE/SME state is live. Thus, aside from the\nwarning, there is no functional issue.\n\nThis bug was introduced during rework to error handling in commit:\n\n  9f8bf718f2923 (\"arm64/fpsimd: ptrace: Gracefully handle errors\")\n\n... where the setting of TIF_SVE was moved into a block which is only\nexecuted when system_supports_sme() is true.\n\nFix this by removing the system_supports_sme() check. This ensures that\nTIF_SVE is set for (SVE-formatted) writes to NT_ARM_SVE, at the cost of\nunconditionally manipulating the tracee's saved svcr value. The\nmanipulation of svcr is benign and inexpensive, and we already do\nsimilar elsewhere (e.g. during signal handling), so I don't think it's\nworth guarding this with system_supports_sme() checks.\n\nAside from the above, there is no functional change. The 'type' argument\nto sve_set_common() is only set to ARM64_VEC_SME (in ssve_set())) when\nsystem_supports_sme(), so the ARM64_VEC_SME case in the switch statement\nis still unreachable when !system_supports_sme(). When\nCONFIG_ARM64_SME=n, the only caller of sve_set_common() is sve_set(),\nand the compiler can constant-fold for the case where type is\nARM64_VEC_SVE, removing the logic for other cases."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad:\n\narm64/fpsimd: ptrace: Corrige escrituras SVE en sistemas sin SME\n\nCuando SVE es compatible pero SME no lo es, una escritura de ptrace al regset NT_ARM_SVE puede colocar al tracee en un estado inválido donde los datos del registro SVE (no streaming) se almacenan en formato FP_STATE_SVE pero TIF_SVE está en cero. Esto puede resultar en una advertencia posterior de fpsimd_restore_current_state(), por ejemplo:\n\n  WARNING: CPU: 0 PID: 7214 at arch/arm64/kernel/fpsimd.c:383 fpsimd_restore_current_state+0x50c/0x748\n\nCuando esto sucede, fpsimd_restore_current_state() establecerá TIF_SVE, colocando la tarea en el estado correcto. Esto ocurre antes de que cualquier otra verificación de TIF_SVE pueda ocurrir, ya que otras verificaciones de TIF_SVE solo suceden mientras el estado FPSIMD/SVE/SME está activo. Por lo tanto, aparte de la advertencia, no hay ningún problema funcional.\n\nEste error fue introducido durante una revisión del manejo de errores en el commit:\n\n  9f8bf718f2923 ('arm64/fpsimd: ptrace: Manejar errores con gracia')\n\n... donde la configuración de TIF_SVE se movió a un bloque que solo se ejecuta cuando system_supports_sme() es verdadero.\n\nEsto se soluciona eliminando la verificación de system_supports_sme(). Esto asegura que TIF_SVE se establezca para escrituras (con formato SVE) a NT_ARM_SVE, a costa de manipular incondicionalmente el valor svcr guardado del tracee. La manipulación de svcr es inofensiva y de bajo costo, y ya hacemos algo similar en otros lugares (por ejemplo, durante el manejo de señales), por lo que no creo que valga la pena condicionar esto a verificaciones de system_supports_sme().\n\nAparte de lo anterior, no hay ningún cambio funcional. El argumento 'type' de sve_set_common() solo se establece en ARM64_VEC_SME (en ssve_set()) cuando system_supports_sme(), por lo que el caso ARM64_VEC_SME en la declaración switch sigue siendo inalcanzable cuando system_supports_sme() es falso. Cuando CONFIG_ARM64_SME=n, el único llamador de sve_set_common() es sve_set(), y el compilador puede realizar plegado de constantes para el caso en que 'type' es ARM64_VEC_SVE, eliminando la lógica para otros casos."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/128a7494a9f15aad60cc6b7e3546bf481ac54a13",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4f39984176e7edcaba3432b6c649c6fe93bf2f80",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}