{
  "id": "CVE-2024-49873",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T18:15:08.763",
  "lastModified": "2024-10-24T20:22:42.387",
  "vulnStatus": "Analyzed",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/filemap: fix filemap_get_folios_contig THP panic\n\nPatch series \"memfd-pin huge page fixes\".\n\nFix multiple bugs that occur when using memfd_pin_folios with hugetlb\npages and THP.  The hugetlb bugs only bite when the page is not yet\nfaulted in when memfd_pin_folios is called.  The THP bug bites when the\nstarting offset passed to memfd_pin_folios is not huge page aligned.  See\nthe commit messages for details.\n\n\nThis patch (of 5):\n\nmemfd_pin_folios on memory backed by THP panics if the requested start\noffset is not huge page aligned:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000036\nRIP: 0010:filemap_get_folios_contig+0xdf/0x290\nRSP: 0018:ffffc9002092fbe8 EFLAGS: 00010202\nRAX: 0000000000000002 RBX: 0000000000000002 RCX: 0000000000000002\n\nThe fault occurs here, because xas_load returns a folio with value 2:\n\n    filemap_get_folios_contig()\n        for (folio = xas_load(&xas); folio && xas.xa_index <= end;\n                        folio = xas_next(&xas)) {\n                ...\n                if (!folio_try_get(folio))   <-- BOOM\n\n\"2\" is an xarray sibling entry.  We get it because memfd_pin_folios does\nnot round the indices passed to filemap_get_folios_contig to huge page\nboundaries for THP, so we load from the middle of a huge page range see a\nsibling.  (It does round for hugetlbfs, at the is_file_hugepages test).\n\nTo fix, if the folio is a sibling, then return the next index as the\nstarting point for the next call to filemap_get_folios_contig."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/filemap: corrección de la serie de parches de pánico de THP filemap_get_folios_contig \"memfd-pin huge page fixes\". Corrige varios errores que ocurren al usar memfd_pin_folios con páginas hugetlb y THP. Los errores de hugetlb solo afectan cuando la página aún no tiene errores cuando se llama a memfd_pin_folios. El error de THP afecta cuando el desplazamiento inicial pasado a memfd_pin_folios no está alineado con la página enorme. Consulte los mensajes de confirmación para obtener más detalles. Este parche (de 5): memfd_pin_folios en la memoria respaldada por THP entra en pánico si el desplazamiento de inicio solicitado no está alineado con una página enorme: ERROR: desreferencia de puntero NULL del núcleo, dirección: 0000000000000036 RIP: 0010:filemap_get_folios_contig+0xdf/0x290 RSP: 0018:ffffc9002092fbe8 EFLAGS: 00010202 RAX: 000000000000002 RBX: 0000000000000002 RCX: 0000000000000002 El error ocurre aquí porque xas_load devuelve un folio con el valor 2: filemap_get_folios_contig() para (folio = xas_load(&amp;xas); folio &amp;&amp; xas.xa_index &lt;= end; folio = xas_next(&amp;xas)) { ... if (!folio_try_get(folio)) &lt;-- BOOM \"2\" es una entrada hermana de xarray. Lo obtenemos porque memfd_pin_folios no redondea los índices pasados a filemap_get_folios_contig a los límites de páginas enormes para THP, por lo que cargamos desde el medio de un rango de páginas enormes para ver un hermano. (Sí redondea para hugetlbfs, en la prueba is_file_hugepages). Para solucionarlo, si el folio es un hermano, entonces devuelva el siguiente índice como punto de inicio para la siguiente llamada a filemap_get_folios_contig."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-476"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.11",
              "versionEndExcluding": "6.11.3",
              "matchCriteriaId": "54D9C704-D679-41A7-9C40-10A6B1E7FFE9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/570dd14bfecf281fa467c80f8ec92b26370ee36a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/c225c4f6056b46a8a5bf2ed35abf17a2d6887691",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}