{
  "id": "CVE-2024-56534",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-12-27T14:15:32.940",
  "lastModified": "2025-01-14T15:49:15.640",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nisofs: avoid memory leak in iocharset\n\nA memleak was found as below:\n\nunreferenced object 0xffff0000d10164d8 (size 8):\n  comm \"pool-udisksd\", pid 108217, jiffies 4295408555\n  hex dump (first 8 bytes):\n    75 74 66 38 00 cc cc cc                          utf8....\n  backtrace (crc de430d31):\n    [<ffff800081046e6c>] kmemleak_alloc+0xb8/0xc8\n    [<ffff8000803e6c3c>] __kmalloc_node_track_caller_noprof+0x380/0x474\n    [<ffff800080363b74>] kstrdup+0x70/0xfc\n    [<ffff80007bb3c6a4>] isofs_parse_param+0x228/0x2c0 [isofs]\n    [<ffff8000804d7f68>] vfs_parse_fs_param+0xf4/0x164\n    [<ffff8000804d8064>] vfs_parse_fs_string+0x8c/0xd4\n    [<ffff8000804d815c>] vfs_parse_monolithic_sep+0xb0/0xfc\n    [<ffff8000804d81d8>] generic_parse_monolithic+0x30/0x3c\n    [<ffff8000804d8bfc>] parse_monolithic_mount_data+0x40/0x4c\n    [<ffff8000804b6a64>] path_mount+0x6c4/0x9ec\n    [<ffff8000804b6e38>] do_mount+0xac/0xc4\n    [<ffff8000804b7494>] __arm64_sys_mount+0x16c/0x2b0\n    [<ffff80008002b8dc>] invoke_syscall+0x7c/0x104\n    [<ffff80008002ba44>] el0_svc_common.constprop.1+0xe0/0x104\n    [<ffff80008002ba94>] do_el0_svc+0x2c/0x38\n    [<ffff800081041108>] el0_svc+0x3c/0x1b8\n\nThe opt->iocharset is freed inside the isofs_fill_super function,\nBut there may be situations where it's not possible to\nenter this function.\n\nFor example, in the get_tree_bdev_flags function,when\nencountering the situation where \"Can't mount, would change RO state,\"\nIn such a case, isofs_fill_super will not have the opportunity\nto be called,which means that opt->iocharset will not have the chance\nto be freed,ultimately leading to a memory leak.\n\nLet's move the memory freeing of opt->iocharset into\nisofs_free_fc function."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: isofs: evitar pérdida de memoria en iocharset Se encontró una pérdida de memoria como la siguiente: objeto sin referencia 0xffff0000d10164d8 (tamaño 8): comm \"pool-udisksd\", pid 108217, jiffies 4295408555 volcado hexadecimal (primeros 8 bytes): 75 74 66 38 00 cc cc cc utf8.... backtrace (crc de430d31): [] kmemleak_alloc+0xb8/0xc8 [] __kmalloc_node_track_caller_noprof+0x380/0x474 [] kstrdup+0x70/0xfc [] parámetro_parse_isofs+0x228/0x2c0 [isofs] [] parámetro_fs_parse_vfs+0xf4/0x164 [] cadena_fs_parse_vfs+0x8c/0xd4 [] sep_monolítico_vfs+0xb0/0xfc [] parámetro_monolítico_genérico+0x30/0x3c [] analizar_datos_de_montaje_monolítico+0x40/0x4c [] ruta_de_montaje+0x6c4/0x9ec [] hacer_montaje+0xac/0xc4 [] __arm64_montaje_del_sistema+0x16c/0x2b0 [] invocar_llamada_del_sistema+0x7c/0x104 [] el0_svc_common.constprop.1+0xe0/0x104 [] do_el0_svc+0x2c/0x38 [] el0_svc+0x3c/0x1b8 El opt-&gt;iocharset se libera dentro de la función isofs_fill_super, pero puede haber situaciones en las que no sea posible ingresar a esta función. Por ejemplo, en la función get_tree_bdev_flags, cuando se encuentra la situación en la que \"No se puede montar, cambiaría el estado de RO\", en tal caso, isofs_fill_super no tendrá la oportunidad de ser llamado, lo que significa que opt-&gt;iocharset no tendrá la oportunidad de ser liberado, lo que finalmente conduce a una pérdida de memoria. Pasemos la liberación de memoria de opt-&gt;iocharset a la función isofs_free_fc."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-401"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.10",
              "versionEndExcluding": "6.11.11",
              "matchCriteriaId": "158A6B22-9260-41D7-965A-A81798A5A969"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.12",
              "versionEndExcluding": "6.12.2",
              "matchCriteriaId": "D8882B1B-2ABC-4838-AC1D-DBDBB5764776"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0b5bbeee4de616a268db77e2f40f19ab010a367b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/0fbab266ca8000333c966f5b58cb9b9cac658573",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/34f090ddb3630a26e5a6b220bf3bfaf5c7b70393",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}