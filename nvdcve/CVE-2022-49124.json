{
  "id": "CVE-2022-49124",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:00:49.740",
  "lastModified": "2025-02-26T07:00:49.740",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/mce: Work around an erratum on fast string copy instructions\n\nA rare kernel panic scenario can happen when the following conditions\nare met due to an erratum on fast string copy instructions:\n\n1) An uncorrected error.\n2) That error must be in first cache line of a page.\n3) Kernel must execute page_copy from the page immediately before that\npage.\n\nThe fast string copy instructions (\"REP; MOVS*\") could consume an\nuncorrectable memory error in the cache line _right after_ the desired\nregion to copy and raise an MCE.\n\nBit 0 of MSR_IA32_MISC_ENABLE can be cleared to disable fast string\ncopy and will avoid such spurious machine checks. However, that is less\npreferable due to the permanent performance impact. Considering memory\npoison is rare, it's desirable to keep fast string copy enabled until an\nMCE is seen.\n\nIntel has confirmed the following:\n1. The CPU erratum of fast string copy only applies to Skylake,\nCascade Lake and Cooper Lake generations.\n\nDirectly return from the MCE handler:\n2. Will result in complete execution of the \"REP; MOVS*\" with no data\nloss or corruption.\n3. Will not result in another MCE firing on the next poisoned cache line\ndue to \"REP; MOVS*\".\n4. Will resume execution from a correct point in code.\n5. Will result in the same instruction that triggered the MCE firing a\nsecond MCE immediately for any other software recoverable data fetch\nerrors.\n6. Is not safe without disabling the fast string copy, as the next fast\nstring copy of the same buffer on the same CPU would result in a PANIC\nMCE.\n\nThis should mitigate the erratum completely with the only caveat that\nthe fast string copy is disabled on the affected hyper thread thus\nperformance degradation.\n\nThis is still better than the OS crashing on MCEs raised on an\nirrelevant process due to \"REP; MOVS*' accesses in a kernel context,\ne.g., copy_page.\n\n\nInjected errors on 1st cache line of 8 anonymous pages of process\n'proc1' and observed MCE consumption from 'proc2' with no panic\n(directly returned).\n\nWithout the fix, the host panicked within a few minutes on a\nrandom 'proc2' process due to kernel access from copy_page.\n\n  [ bp: Fix comment style + touch ups, zap an unlikely(), improve the\n    quirk function's readability. ]"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86/mce: Workaround a una errata en instrucciones de copia rápida de cadenas Un escenario poco común de pánico del kernel puede ocurrir cuando se cumplen las siguientes condiciones debido a una errata en instrucciones de copia rápida de cadenas: 1) Un error sin corregir. 2) Ese error debe estar en la primera línea de caché de una página. 3) El kernel debe ejecutar page_copy desde la página inmediatamente anterior a esa página. Las instrucciones de copia rápida de cadenas (\"REP; MOVS*\") podrían consumir un error de memoria incorregible en la línea de caché _justo después_ de la región deseada para copiar y generar un MCE. El bit 0 de MSR_IA32_MISC_ENABLE se puede borrar para deshabilitar la copia rápida de cadenas y evitará tales verificaciones de máquina falsas. Sin embargo, eso es menos preferible debido al impacto permanente en el rendimiento. Teniendo en cuenta que el envenenamiento de memoria es poco común, es deseable mantener habilitada la copia rápida de cadenas hasta que se vea un MCE. Intel ha confirmado lo siguiente: 1. La errata de la CPU de la copia rápida de cadenas solo se aplica a las generaciones Skylake, Cascade Lake y Cooper Lake. Regresa directamente del controlador MCE: 2. Dará como resultado la ejecución completa de \"REP; MOVS*\" sin pérdida ni corrupción de datos. 3. No dará como resultado que se active otro MCE en la siguiente línea de caché envenenada debido a \"REP; MOVS*\". 4. Reanudará la ejecución desde un punto correcto en el código. 5. Dará como resultado que la misma instrucción que activó el MCE active un segundo MCE inmediatamente para cualquier otro error de obtención de datos recuperable por software. 6. No es seguro sin deshabilitar la copia rápida de cadenas, ya que la próxima copia rápida de cadenas del mismo búfer en la misma CPU daría como resultado un MCE de PANIC. Esto debería mitigar la errata por completo con la única salvedad de que la copia rápida de cadenas está deshabilitada en el hiperproceso afectado, por lo que se degrada el rendimiento. Esto es aún mejor que el bloqueo del sistema operativo en MCE generados en un proceso irrelevante debido a accesos \"REP; MOVS*\" en un contexto de kernel, por ejemplo, copy_page. Se inyectaron errores en la primera línea de caché de 8 páginas anónimas del proceso \"proc1\" y se observó el consumo de MCE de \"proc2\" sin pánico (devuelto directamente). Sin la solución, el host entró en pánico en unos pocos minutos en un proceso \"proc2\" aleatorio debido al acceso al kernel desde copy_page. [bp: Corregir el estilo de comentario + retoques, eliminar un Unlikely(), mejorar la legibilidad de la función Quirk.]"
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/8ca97812c3c830573f965a07bbd84223e8c5f5bd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ba37c73be3d5632f6fb9fa20b250ce45560ca85d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}