{
  "id": "CVE-2022-49559",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:01:31.687",
  "lastModified": "2025-02-26T07:01:31.687",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Drop WARNs that assert a triple fault never \"escapes\" from L2\n\nRemove WARNs that sanity check that KVM never lets a triple fault for L2\nescape and incorrectly end up in L1.  In normal operation, the sanity\ncheck is perfectly valid, but it incorrectly assumes that it's impossible\nfor userspace to induce KVM_REQ_TRIPLE_FAULT without bouncing through\nKVM_RUN (which guarantees kvm_check_nested_state() will see and handle\nthe triple fault).\n\nThe WARN can currently be triggered if userspace injects a machine check\nwhile L2 is active and CR4.MCE=0.  And a future fix to allow save/restore\nof KVM_REQ_TRIPLE_FAULT, e.g. so that a synthesized triple fault isn't\nlost on migration, will make it trivially easy for userspace to trigger\nthe WARN.\n\nClearing KVM_REQ_TRIPLE_FAULT when forcibly leaving guest mode is\ntempting, but wrong, especially if/when the request is saved/restored,\ne.g. if userspace restores events (including a triple fault) and then\nrestores nested state (which may forcibly leave guest mode).  Ignoring\nthe fact that KVM doesn't currently provide the necessary APIs, it's\nuserspace's responsibility to manage pending events during save/restore.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 7 PID: 1399 at arch/x86/kvm/vmx/nested.c:4522 nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]\n  Modules linked in: kvm_intel kvm irqbypass\n  CPU: 7 PID: 1399 Comm: state_test Not tainted 5.17.0-rc3+ #808\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]\n  Call Trace:\n   <TASK>\n   vmx_leave_nested+0x30/0x40 [kvm_intel]\n   vmx_set_nested_state+0xca/0x3e0 [kvm_intel]\n   kvm_arch_vcpu_ioctl+0xf49/0x13e0 [kvm]\n   kvm_vcpu_ioctl+0x4b9/0x660 [kvm]\n   __x64_sys_ioctl+0x83/0xb0\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n   </TASK>\n  ---[ end trace 0000000000000000 ]---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86: Eliminar WARNs que afirman que un triple fallo nunca \"escapa\" de L2 Eliminar WARNs que comprueban que KVM nunca permite que un triple fallo para L2 escape y termine incorrectamente en L1. En funcionamiento normal, la comprobación de cordura es perfectamente válida, pero supone incorrectamente que es imposible para el espacio de usuario inducir KVM_REQ_TRIPLE_FAULT sin rebotar a través de KVM_RUN (lo que garantiza que kvm_check_nested_state() verá y manejará el triple fallo). El WARN se puede activar actualmente si el espacio de usuario inyecta una comprobación de máquina mientras L2 está activo y CR4.MCE=0. Y una solución futura para permitir guardar/restaurar KVM_REQ_TRIPLE_FAULT, por ejemplo, para que un triple fallo sintetizado no se pierda en la migración, hará que sea trivialmente fácil para el espacio de usuario activar el WARN. Borrar KVM_REQ_TRIPLE_FAULT al salir forzosamente del modo invitado es tentador, pero incorrecto, especialmente si/cuando la solicitud se guarda/restaura, por ejemplo, si el espacio de usuario restaura eventos (incluido un triple error) y luego restaura el estado anidado (que puede salir forzosamente del modo invitado). Si ignoramos el hecho de que KVM actualmente no proporciona las API necesarias, es responsabilidad del espacio de usuario administrar los eventos pendientes durante el guardado/restauración. ------------[ cortar aquí ]------------ ADVERTENCIA: CPU: 7 PID: 1399 at arch/x86/kvm/vmx/nested.c:4522 nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel] Modules linked in: kvm_intel kvm irqbypass CPU: 7 PID: 1399 Comm: state_test Not tainted 5.17.0-rc3+ #808 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 RIP: 0010:nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel] Call Trace:  vmx_leave_nested+0x30/0x40 [kvm_intel] vmx_set_nested_state+0xca/0x3e0 [kvm_intel] kvm_arch_vcpu_ioctl+0xf49/0x13e0 [kvm] kvm_vcpu_ioctl+0x4b9/0x660 [kvm] __x64_sys_ioctl+0x83/0xb0 do_syscall_64+0x3b/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae  ---[ end trace 0000000000000000 ]--- "
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/45846661d10422ce9e22da21f8277540b29eca22",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7de373c9b48229e428ecdb8fbde269c5a8617fd2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8d3a2aa0976f57320ba89baf9d57fb158dd0cd0d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f476a59d5c86c02a79eef893c6da86735f2977ac",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}