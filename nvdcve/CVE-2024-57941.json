{
  "id": "CVE-2024-57941",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-01-21T13:15:08.640",
  "lastModified": "2025-01-21T13:15:08.640",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Fix the (non-)cancellation of copy when cache is temporarily disabled\n\nWhen the caching for a cookie is temporarily disabled (e.g. due to a DIO\nwrite on that file), future copying to the cache for that file is disabled\nuntil all fds open on that file are closed.  However, if netfslib is using\nthe deprecated PG_private_2 method (such as is currently used by ceph), and\ndecides it wants to copy to the cache, netfs_advance_write() will just bail\nat the first check seeing that the cache stream is unavailable, and\nindicate that it dealt with all the content.\n\nThis means that we have no subrequests to provide notifications to drive\nthe state machine or even to pin the request and the request just gets\ndiscarded, leaving the folios with PG_private_2 set.\n\nFix this by jumping directly to cancel the request if the cache is not\navailable.  That way, we don't remove mark3 from the folio_queue list and\nnetfs_pgpriv2_cancel() will clean up the folios.\n\nThis was found by running the generic/013 xfstest against ceph with an\nactive cache and the \"-o fsc\" option passed to ceph.  That would usually\nhang"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfs: Arreglar la (no) cancelación de copia cuando el caché está deshabilitado temporalmente Cuando el almacenamiento en caché de una cookie está deshabilitado temporalmente (por ejemplo, debido a una escritura DIO en ese archivo), la copia futura al caché para ese archivo se deshabilita hasta que todos los fds abiertos en ese archivo se cierren. Sin embargo, si netfslib está usando el método PG_private_2 obsoleto (como el que usa actualmente ceph) y decide que quiere copiar al caché, netfs_advance_write() simplemente abandonará en la primera verificación al ver que el flujo de caché no está disponible e indicará que se ocupó de todo el contenido. Esto significa que no tenemos subsolicitudes para proporcionar notificaciones para controlar la máquina de estado o incluso para fijar la solicitud y la solicitud simplemente se descarta, dejando los folios con PG_private_2 establecido. Arregle esto saltando directamente para cancelar la solicitud si el caché no está disponible. De esa manera, no eliminamos mark3 de la lista folio_queue y netfs_pgpriv2_cancel() limpiará los folios. Esto se descubrió al ejecutar el xfstest genérico/013 contra ceph con un caché activo y la opción \"-o fsc\" pasada a ceph. Eso generalmente se bloqueaba"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/ba37bdfe59fb43e80dd79290340a21864ba4b61e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d0327c824338cdccad058723a31d038ecd553409",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}