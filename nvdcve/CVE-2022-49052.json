{
  "id": "CVE-2022-49052",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:00:42.463",
  "lastModified": "2025-02-26T07:00:42.463",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix unexpected zeroed page mapping with zram swap\n\nTwo processes under CLONE_VM cloning, user process can be corrupted by\nseeing zeroed page unexpectedly.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n  swap_readpage valid data\n    swap_slot_free_notify\n      delete zram entry\n                              swap_readpage zeroed(invalid) data\n                              pte_lock\n                              map the *zero data* to userspace\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return and next refault will\n  read zeroed data\n\nThe swap_slot_free_notify is bogus for CLONE_VM case since it doesn't\nincrease the refcount of swap slot at copy_mm so it couldn't catch up\nwhether it's safe or not to discard data from backing device.  In the\ncase, only the lock it could rely on to synchronize swap slot freeing is\npage table lock.  Thus, this patch gets rid of the swap_slot_free_notify\nfunction.  With this patch, CPU A will see correct data.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n                              swap_readpage original data\n                              pte_lock\n                              map the original data\n                              swap_free\n                                swap_range_free\n                                  bd_disk->fops->swap_slot_free_notify\n  swap_readpage read zeroed data\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return\n  on next refault will see mapped data by CPU B\n\nThe concern of the patch would increase memory consumption since it\ncould keep wasted memory with compressed form in zram as well as\nuncompressed form in address space.  However, most of cases of zram uses\nno readahead and do_swap_page is followed by swap_free so it will free\nthe compressed form from in zram quickly."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: corregir la asignación inesperada de páginas en cero con intercambio de zram Dos procesos bajo la clonación CLONE_VM, el proceso del usuario puede corromperse al ver una página en cero inesperadamente. CPU A CPU B do_swap_page do_swap_page SWP_SYNCHRONOUS_IO ruta SWP_SYNCHRONOUS_IO ruta swap_readpage datos válidos swap_slot_free_notify eliminar entrada zram swap_readpage datos cero (inválidos) pte_lock asigna los *datos cero* al espacio de usuario pte_unlock pte_lock if (!pte_same) goto out_nomap; pte_unlock return y el siguiente refault leerá los datos en cero swap_slot_free_notify es falso para el caso de CLONE_VM ya que no aumenta el recuento de referencias de la ranura de intercambio en copy_mm, por lo que no podría ponerse al día si es seguro o no descartar datos del dispositivo de respaldo. En este caso, el único bloqueo en el que podría confiar para sincronizar la liberación de la ranura de intercambio es el bloqueo de la tabla de páginas. Por lo tanto, este parche elimina la función swap_slot_free_notify. Con este parche, la CPU A verá los datos correctos. CPU A CPU B do_swap_page do_swap_page SWP_SYNCHRONOUS_IO path SWP_SYNCHRONOUS_IO path swap_readpage original data pte_lock map the original data swap_free swap_range_free bd_disk-&gt;fops-&gt;swap_slot_free_notify swap_readpage read zeroed data pte_unlock pte_lock if (!pte_same) goto out_nomap; pte_unlock return on next refault verá los datos mapeados por la CPU B La preocupación del parche aumentaría el consumo de memoria ya que podría mantener la memoria desperdiciada con forma comprimida en zram así como forma sin comprimir en el espacio de direcciones. Sin embargo, la mayoría de los casos de zram no utilizan lectura anticipada y do_swap_page es seguido por swap_free por lo que liberará el formato comprimido de zram rápidamente."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/12ba1d38115a101c45d8e0ca3aa1181fd148e57f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/20ed94f8181a25212e7404e44958e234f407624b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/afac4b88699a06c8b9369f9d759a1ec3c254b788",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e914d8f00391520ecc4495dd0ca0124538ab7119",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f098f8b9820fe3f2e41aefc4329dfe8a3859d1c1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f86d55cf616199404c05f5b0c5c41b17351baa02",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}