{
  "id": "CVE-2023-52881",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-29T11:16:02.110",
  "lastModified": "2024-11-21T08:40:47.353",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: do not accept ACK of bytes we never sent\n\nThis patch is based on a detailed report and ideas from Yepeng Pan\nand Christian Rossow.\n\nACK seq validation is currently following RFC 5961 5.2 guidelines:\n\n   The ACK value is considered acceptable only if\n   it is in the range of ((SND.UNA - MAX.SND.WND) <= SEG.ACK <=\n   SND.NXT).  All incoming segments whose ACK value doesn't satisfy the\n   above condition MUST be discarded and an ACK sent back.  It needs to\n   be noted that RFC 793 on page 72 (fifth check) says: \"If the ACK is a\n   duplicate (SEG.ACK < SND.UNA), it can be ignored.  If the ACK\n   acknowledges something not yet sent (SEG.ACK > SND.NXT) then send an\n   ACK, drop the segment, and return\".  The \"ignored\" above implies that\n   the processing of the incoming data segment continues, which means\n   the ACK value is treated as acceptable.  This mitigation makes the\n   ACK check more stringent since any ACK < SND.UNA wouldn't be\n   accepted, instead only ACKs that are in the range ((SND.UNA -\n   MAX.SND.WND) <= SEG.ACK <= SND.NXT) get through.\n\nThis can be refined for new (and possibly spoofed) flows,\nby not accepting ACK for bytes that were never sent.\n\nThis greatly improves TCP security at a little cost.\n\nI added a Fixes: tag to make sure this patch will reach stable trees,\neven if the 'blamed' patch was adhering to the RFC.\n\ntp->bytes_acked was added in linux-4.2\n\nFollowing packetdrill test (courtesy of Yepeng Pan) shows\nthe issue at hand:\n\n0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n+0 bind(3, ..., ...) = 0\n+0 listen(3, 1024) = 0\n\n// ---------------- Handshake ------------------- //\n\n// when window scale is set to 14 the window size can be extended to\n// 65535 * (2^14) = 1073725440. Linux would accept an ACK packet\n// with ack number in (Server_ISN+1-1073725440. Server_ISN+1)\n// ,though this ack number acknowledges some data never\n// sent by the server.\n\n+0 < S 0:0(0) win 65535 <mss 1400,nop,wscale 14>\n+0 > S. 0:0(0) ack 1 <...>\n+0 < . 1:1(0) ack 1 win 65535\n+0 accept(3, ..., ...) = 4\n\n// For the established connection, we send an ACK packet,\n// the ack packet uses ack number 1 - 1073725300 + 2^32,\n// where 2^32 is used to wrap around.\n// Note: we used 1073725300 instead of 1073725440 to avoid possible\n// edge cases.\n// 1 - 1073725300 + 2^32 = 3221241997\n\n// Oops, old kernels happily accept this packet.\n+0 < . 1:1001(1000) ack 3221241997 win 65535\n\n// After the kernel fix the following will be replaced by a challenge ACK,\n// and prior malicious frame would be dropped.\n+0 > . 1:1(0) ack 1001"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tcp: no acepta ACK de bytes que nunca enviamos. Este parche se basa en un informe detallado e ideas de Yepeng Pan y Christian Rossow. La validación de secuencia de ACK sigue actualmente las pautas RFC 5961 5.2: El valor de ACK se considera aceptable solo si está en el rango de ((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK &lt;= SND.NXT). Todos los segmentos entrantes cuyo valor ACK no satisface la condición anterior DEBEN descartarse y enviarse un ACK. Es necesario tener en cuenta que RFC 793 en la página 72 (quinta verificación) dice: \"Si el ACK es un duplicado (SEG.ACK &lt; SND.UNA), se puede ignorar. Si el ACK reconoce algo que aún no se ha enviado (SEG. ACK &gt; SND.NXT) luego envía un ACK, descarta el segmento y regresa\". Lo \"ignorado\" anterior implica que el procesamiento del segmento de datos entrantes continúa, lo que significa que el valor ACK se trata como aceptable. Esta mitigación hace que la verificación de ACK sea más estricta, ya que no se aceptará ningún ACK &lt; SND.UNA; en su lugar, solo se aceptarán ACK que estén en el rango ((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK &lt;= SND. NXT) pasar. Esto se puede perfeccionar para flujos nuevos (y posiblemente falsificados) al no aceptar ACK para bytes que nunca se enviaron. Esto mejora enormemente la seguridad de TCP a un costo reducido. Agregué una etiqueta Correcciones: para asegurarme de que este parche llegue a árboles estables, incluso si el parche \"culpado\" se adhirió al RFC. tp-&gt;bytes_acked se agregó en Linux-4.2 La siguiente prueba de packagedrill (cortesía de Yepeng Pan) muestra el problema en cuestión: 0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3 +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1 ], 4) = 0 +0 enlazar(3, ..., ...) = 0 +0 escuchar(3, 1024) = 0 // ---------------- Apretón de manos ------------------- // // cuando la escala de la ventana se establece en 14, el tamaño de la ventana se puede ampliar a // 65535 * (2^14) = 1073725440. Linux aceptaría un paquete ACK // con un número de reconocimiento en (Server_ISN+1-1073725440. Server_ISN+1) //, aunque este número de reconocimiento reconoce algunos datos // nunca enviados por el servidor. +0 &lt; S 0:0(0) win 65535  +0 &gt; S. 0:0(0) ack 1 &lt;...&gt; +0 &lt; . 1:1(0) ack 1 win 65535 +0 aceptar(3, ..., ...) = 4 // Para la conexión establecida, enviamos un paquete ACK, // el paquete de confirmación utiliza el número de confirmación 1 - 1073725300 + 2^32, // donde 2^32 se usa para envolver. // Nota: utilizamos 1073725300 en lugar de 1073725440 para evitar posibles // casos extremos. // 1 - 1073725300 + 2^32 = 3221241997 // Vaya, los núcleos antiguos aceptan felizmente este paquete. +0 &lt;. 1:1001(1000) ACK 3221241997 win 65535 // Después de la corrección del kernel, lo siguiente será reemplazado por un ACK de desafío, // y el marco malicioso anterior se eliminará. +0 &gt; . 1:1(0) reconocimiento 1001"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/008b807fe487e0b15a3a6c39add4eb477f73e440",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/0d4e0afdd6658cd21dd5be61880411a2553fd1fc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2087d53a66e97a5eb5d1bf558d5bef9e5f891757",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3d501dd326fb1c73f1b8206d4c6e1d7b15c07e27",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/458f07ffeccd17f99942311e09ef574ddf4a414a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/69eae75ca5255e876628ac5cee9eaab31f644b57",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7ffff0cc929fdfc62a74b384c4903d6496c910f0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b17a886ed29f3b70b78ccf632dad03e0c69e3c1a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/008b807fe487e0b15a3a6c39add4eb477f73e440",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/0d4e0afdd6658cd21dd5be61880411a2553fd1fc",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/2087d53a66e97a5eb5d1bf558d5bef9e5f891757",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/3d501dd326fb1c73f1b8206d4c6e1d7b15c07e27",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/458f07ffeccd17f99942311e09ef574ddf4a414a",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/69eae75ca5255e876628ac5cee9eaab31f644b57",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/7ffff0cc929fdfc62a74b384c4903d6496c910f0",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/b17a886ed29f3b70b78ccf632dad03e0c69e3c1a",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}