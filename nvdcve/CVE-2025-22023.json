{
  "id": "CVE-2025-22023",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-16T11:15:42.987",
  "lastModified": "2025-04-16T13:25:37.340",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: xhci: Don't skip on Stopped - Length Invalid\n\nUp until commit d56b0b2ab142 (\"usb: xhci: ensure skipped isoc TDs are\nreturned when isoc ring is stopped\") in v6.11, the driver didn't skip\nmissed isochronous TDs when handling Stoppend and Stopped - Length\nInvalid events. Instead, it erroneously cleared the skip flag, which\nwould cause the ring to get stuck, as future events won't match the\nmissed TD which is never removed from the queue until it's cancelled.\n\nThis buggy logic seems to have been in place substantially unchanged\nsince the 3.x series over 10 years ago, which probably speaks first\nand foremost about relative rarity of this case in normal usage, but\nby the spec I see no reason why it shouldn't be possible.\n\nAfter d56b0b2ab142, TDs are immediately skipped when handling those\nStopped events. This poses a potential problem in case of Stopped -\nLength Invalid, which occurs either on completed TDs (likely already\ngiven back) or Link and No-Op TRBs. Such event won't be recognized\nas matching any TD (unless it's the rare Link TRB inside a TD) and\nwill result in skipping all pending TDs, giving them back possibly\nbefore they are done, risking isoc data loss and maybe UAF by HW.\n\nAs a compromise, don't skip and don't clear the skip flag on this\nkind of event. Then the next event will skip missed TDs. A downside\nof not handling Stopped - Length Invalid on a Link inside a TD is\nthat if the TD is cancelled, its actual length will not be updated\nto account for TRBs (silently) completed before the TD was stopped.\n\nI had no luck producing this sequence of completion events so there\nis no compelling demonstration of any resulting disaster. It may be\na very rare, obscure condition. The sole motivation for this patch\nis that if such unlikely event does occur, I'd rather risk reporting\na cancelled partially done isoc frame as empty than gamble with UAF.\n\nThis will be fixed more properly by looking at Stopped event's TRB\npointer when making skipping decisions, but such rework is unlikely\nto be backported to v6.12, which will stay around for a few years."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: xhci: Don't skip on Stopped - Length Invalid Hasta el commit d56b0b2ab142 (\"usb: xhci: ensure skipped isoc TDs are returns when is stopped ring\") en v6.11, el controlador no omitía los TD isócronos omitidos al gestionar los eventos Stoppend y Stopped - Length Invalid. En su lugar, borraba erróneamente el indicador de omisión, lo que provocaría que el anillo se atascara, ya que los eventos futuros no coincidirán con el TD omitido, que nunca se elimina de la cola hasta que se cancela. Esta lógica defectuosa parece haber estado en su lugar sustancialmente sin cambios desde la serie 3.x hace más de 10 años, lo que probablemente habla en primer lugar sobre la relativa rareza de este caso en el uso normal, pero por la especificación no veo razón por la que no debería ser posible. Después de d56b0b2ab142, los TD se omiten inmediatamente al gestionar los eventos \"Detenidos\". Esto plantea un problema potencial en caso de \"Detenido - Longitud Inválida\", que ocurre en TD completados (probablemente ya devueltos) o en TRB de Enlace y No-Op. Este evento no se reconocerá como coincidente con ningún TD (a menos que se trate del inusual TRB de Enlace dentro de un TD) y provocará la omisión de todos los TD pendientes, devolviéndolos posiblemente antes de que finalicen, con el riesgo de pérdida de datos de isoc y posiblemente un fallo de hardware no operativo (UAF). Como solución intermedia, no omita ni borre el indicador de omisión en este tipo de evento. De este modo, el siguiente evento omitirá los TD omitidos. Una desventaja de no gestionar \"Detenido - Longitud Inválida\" en un Enlace dentro de un TD es que, si el TD se cancela, su longitud real no se actualizará para tener en cuenta los TRB completados (silenciosamente) antes de que se detuviera el TD. No tuve éxito en generar esta secuencia de eventos de finalización, por lo que no hay una demostración convincente de ningún desastre resultante. Puede ser una condición muy rara y desconocida. La única motivación para este parche es que, si ocurre un evento tan improbable, prefiero arriesgarme a reportar un marco isoc cancelado parcialmente completado como vacío que arriesgarme con UAF. Esto se solucionará mejor analizando el puntero TRB del evento detenido al tomar decisiones de omisión, pero es poco probable que esta modificación se incorpore a la versión 6.12, que se mantendrá vigente durante algunos años."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/49cf6f5293aeb706dd672608478336a003f37df6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/58d0a3fab5f4fdc112c16a4c6d382f62097afd1c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/6af20ac254cbd0e1178a3542767c9308e209eee5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/de9e78167f760a699806793d7c987239e4f6c8c3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}