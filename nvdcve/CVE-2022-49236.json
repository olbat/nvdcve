{
  "id": "CVE-2022-49236",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:01:00.600",
  "lastModified": "2025-03-25T15:08:09.460",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix UAF due to race between btf_try_get_module and load_module\n\nWhile working on code to populate kfunc BTF ID sets for module BTF from\nits initcall, I noticed that by the time the initcall is invoked, the\nmodule BTF can already be seen by userspace (and the BPF verifier). The\nexisting btf_try_get_module calls try_module_get which only fails if\nmod->state == MODULE_STATE_GOING, i.e. it can increment module reference\nwhen module initcall is happening in parallel.\n\nCurrently, BTF parsing happens from MODULE_STATE_COMING notifier\ncallback. At this point, the module initcalls have not been invoked.\nThe notifier callback parses and prepares the module BTF, allocates an\nID, which publishes it to userspace, and then adds it to the btf_modules\nlist allowing the kernel to invoke btf_try_get_module for the BTF.\n\nHowever, at this point, the module has not been fully initialized (i.e.\nits initcalls have not finished). The code in module.c can still fail\nand free the module, without caring for other users. However, nothing\nstops btf_try_get_module from succeeding between the state transition\nfrom MODULE_STATE_COMING to MODULE_STATE_LIVE.\n\nThis leads to a use-after-free issue when BPF program loads\nsuccessfully in the state transition, load_module's do_init_module call\nfails and frees the module, and BPF program fd on close calls module_put\nfor the freed module. Future patch has test case to verify we don't\nregress in this area in future.\n\nThere are multiple points after prepare_coming_module (in load_module)\nwhere failure can occur and module loading can return error. We\nillustrate and test for the race using the last point where it can\npractically occur (in module __init function).\n\nAn illustration of the race:\n\nCPU 0                           CPU 1\n\t\t\t  load_module\n\t\t\t    notifier_call(MODULE_STATE_COMING)\n\t\t\t      btf_parse_module\n\t\t\t      btf_alloc_id\t// Published to userspace\n\t\t\t      list_add(&btf_mod->list, btf_modules)\n\t\t\t    mod->init(...)\n...\t\t\t\t^\nbpf_check\t\t        |\ncheck_pseudo_btf_id             |\n  btf_try_get_module            |\n    returns true                |  ...\n...                             |  module __init in progress\nreturn prog_fd                  |  ...\n...                             V\n\t\t\t    if (ret < 0)\n\t\t\t      free_module(mod)\n\t\t\t    ...\nclose(prog_fd)\n ...\n bpf_prog_free_deferred\n  module_put(used_btf.mod) // use-after-free\n\nWe fix this issue by setting a flag BTF_MODULE_F_LIVE, from the notifier\ncallback when MODULE_STATE_LIVE state is reached for the module, so that\nwe return NULL from btf_try_get_module for modules that are not fully\nformed. Since try_module_get already checks that module is not in\nMODULE_STATE_GOING state, and that is the only transition a live module\ncan make before being removed from btf_modules list, this is enough to\nclose the race and prevent the bug.\n\nA later selftest patch crafts the race condition artifically to verify\nthat it has been fixed, and that verifier fails to load program (with\nENXIO).\n\nLastly, a couple of comments:\n\n 1. Even if this race didn't exist, it seems more appropriate to only\n    access resources (ksyms and kfuncs) of a fully formed module which\n    has been initialized completely.\n\n 2. This patch was born out of need for synchronization against module\n    initcall for the next patch, so it is needed for correctness even\n    without the aforementioned race condition. The BTF resources\n    initialized by module initcall are set up once and then only looked\n    up, so just waiting until the initcall has finished ensures correct\n    behavior."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Arreglar UAF debido a la ejecución entre btf_try_get_module y load_module Mientras trabajaba en el código para rellenar los conjuntos de ID de BTF de kfunc para el módulo BTF desde su initcall, noté que para el momento en que se invoca la initcall, el espacio de usuario (y el verificador BPF) ya puede ver el módulo BTF. El btf_try_get_module existente llama a try_module_get, que solo falla si mod-&gt;state == MODULE_STATE_GOING, es decir, puede incrementar la referencia del módulo cuando la initcall del módulo está sucediendo en paralelo. Actualmente, el análisis de BTF ocurre desde la devolución de llamada del notificador MODULE_STATE_COMING. En este punto, las initcalls del módulo no han sido invocadas. La devolución de llamada del notificador analiza y prepara el módulo BTF, asigna un ID, que lo publica en el espacio de usuario y luego lo agrega a la lista btf_modules, lo que permite que el núcleo invoque btf_try_get_module para el BTF. Sin embargo, en este punto, el módulo no se ha inicializado por completo (es decir, sus llamadas de inicio no han finalizado). El código en module.c aún puede fallar y liberar el módulo, sin preocuparse por otros usuarios. Sin embargo, nada impide que btf_try_get_module tenga éxito entre la transición de estado de MODULE_STATE_COMING a MODULE_STATE_LIVE. Esto conduce a un problema de use-after-free cuando el programa BPF se carga correctamente en la transición de estado, la llamada do_init_module de load_module falla y libera el módulo, y el programa BPF fd al cerrar llama a module_put para el módulo liberado. El parche futuro tiene un caso de prueba para verificar que no retrocedamos en esta área en el futuro. Hay varios puntos después de prepare_coming_module (en load_module) donde puede ocurrir un fallo y la carga del módulo puede devolver un error. Ilustramos y probamos la ejecución usando el último punto donde puede ocurrir prácticamente (en la función __init del módulo). Una ilustración de la ejecución: CPU 0 CPU 1 load_module notifier_call(MODULE_STATE_COMING) btf_parse_module btf_alloc_id // Publicado en el espacio de usuario list_add(&amp;btf_mod-&gt;list, btf_modules) mod-&gt;init(...) ... ^ bpf_check | check_pseudo_btf_id | btf_try_get_module | devuelve verdadero | ... ... | módulo __init en progreso devuelve prog_fd | ... ... V if (ret &lt; 0) free_module(mod) ... close(prog_fd) ... bpf_prog_free_deferred module_put(used_btf.mod) // use-after-free Solucionamos este problema estableciendo un indicador BTF_MODULE_F_LIVE, desde la devolución de llamada del notificador cuando se alcanza el estado MODULE_STATE_LIVE para el módulo, de modo que devolvamos NULL desde btf_try_get_module para los módulos que no están completamente formados. Dado que try_module_get ya verifica que el módulo no esté en el estado MODULE_STATE_GOING, y esa es la única transición que un módulo activo puede hacer antes de ser eliminado de la lista btf_modules, esto es suficiente para cerrar la ejecución y evitar el error. Un parche de autoprueba posterior crea la condición de ejecución artificialmente para verificar que se ha solucionado, y que el verificador no puede cargar el programa (con ENXIO). Por último, un par de comentarios: 1. Incluso si esta ejecución no existiera, parece más apropiado acceder solo a los recursos (ksyms y kfuncs) de un módulo completamente formado que se haya inicializado por completo. 2. Este parche nació de la necesidad de sincronización con el módulo initcall para el próximo parche, por lo que es necesario para la corrección incluso sin la condición de ejecución mencionada anteriormente. Los recursos BTF inicializados por el módulo initcall se configuran una vez y luego solo se buscan, por lo que simplemente esperar hasta que el initcall haya terminado garantiza un comportamiento correcto."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
        "type": "Secondary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "baseScore": 7.8,
          "baseSeverity": "HIGH",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "HIGH",
          "integrityImpact": "HIGH",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 5.9
      }
    ]
  },
  "weaknesses": [
    {
      "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
      "type": "Secondary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-416"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.12",
              "versionEndExcluding": "5.15.33",
              "matchCriteriaId": "02AF1052-DC50-47B3-B1DE-638E4BBDCCD1"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.16",
              "versionEndExcluding": "5.16.19",
              "matchCriteriaId": "20C43679-0439-405A-B97F-685BEE50613B"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.17",
              "versionEndExcluding": "5.17.2",
              "matchCriteriaId": "210C679C-CF84-44A3-8939-E629C87E54BF"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0481baa2318cb1ab13277715da6cdbb657807b3f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/18688de203b47e5d8d9d0953385bf30b5949324f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/51b82141fffa454abf937a8ff0b8af89e4fd0c8f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/d7fccf264b1a785525b366a5b7f8113c756187ad",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}