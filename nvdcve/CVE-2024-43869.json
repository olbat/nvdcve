{
  "id": "CVE-2024-43869",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-08-21T01:15:11.550",
  "lastModified": "2024-08-21T12:30:33.697",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix event leak upon exec and file release\n\nThe perf pending task work is never waited upon the matching event\nrelease. In the case of a child event, released via free_event()\ndirectly, this can potentially result in a leaked event, such as in the\nfollowing scenario that doesn't even require a weak IRQ work\nimplementation to trigger:\n\nschedule()\n   prepare_task_switch()\n=======> <NMI>\n      perf_event_overflow()\n         event->pending_sigtrap = ...\n         irq_work_queue(&event->pending_irq)\n<======= </NMI>\n      perf_event_task_sched_out()\n          event_sched_out()\n              event->pending_sigtrap = 0;\n              atomic_long_inc_not_zero(&event->refcount)\n              task_work_add(&event->pending_task)\n   finish_lock_switch()\n=======> <IRQ>\n   perf_pending_irq()\n      //do nothing, rely on pending task work\n<======= </IRQ>\n\nbegin_new_exec()\n   perf_event_exit_task()\n      perf_event_exit_event()\n         // If is child event\n         free_event()\n            WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1)\n            // event is leaked\n\nSimilar scenarios can also happen with perf_event_remove_on_exec() or\nsimply against concurrent perf_event_release().\n\nFix this with synchonizing against the possibly remaining pending task\nwork while freeing the event, just like is done with remaining pending\nIRQ work. This means that the pending task callback neither need nor\nshould hold a reference to the event, preventing it from ever beeing\nfreed."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: perf: corrige la fuga de eventos al liberar el archivo y el ejecutable. El trabajo de la tarea pendiente de rendimiento nunca se espera hasta que se libere el evento correspondiente. En el caso de un evento secundario, publicado directamente a través de free_event(), esto puede potencialmente resultar en un evento filtrado, como en el siguiente escenario que ni siquiera requiere una implementación de trabajo IRQ débil para activarse: Schedule() prepare_task_switch() =======&gt;  perf_event_overflow() evento-&gt;pending_sigtrap = ... irq_work_queue(&amp;event-&gt;pending_irq) &lt;=======  perf_event_task_sched_out() event_sched_out() evento-&gt; pendiente_sigtrap = 0; atomic_long_inc_not_zero(&amp;event-&gt;refcount) task_work_add(&amp;event-&gt;pending_task) Finish_lock_switch() =======&gt;  perf_pending_irq() //no hacer nada, confiar en el trabajo de la tarea pendiente &lt;======= &lt; /IRQ&gt; comenzar_new_exec() perf_event_exit_task() perf_event_exit_event() // Si es un evento secundario free_event() WARN(atomic_long_cmpxchg(&amp;event-&gt;refcount, 1, 0) != 1) // el evento se filtró También pueden ocurrir escenarios similares con perf_event_remove_on_exec () o simplemente contra perf_event_release() concurrente. Solucione este problema sincronizando con el trabajo de tarea pendiente posiblemente restante mientras se libera el evento, tal como se hace con el trabajo de IRQ pendiente restante. Esto significa que la devolución de llamada de la tarea pendiente no necesita ni debe contener una referencia al evento, lo que impide que se libere."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/104e258a004037bc7dba9f6085c71dad6af57ad4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3a5465418f5fd970e86a86c7f4075be262682840",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9ad46f1fef421d43cdab3a7d1744b2f43b54dae0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ed2c202dac55423a52d7e2290f2888bf08b8ee99",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f34d8307a73a18de5320fcc6f40403146d061891",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}