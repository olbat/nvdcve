{
  "id": "CVE-2021-47460",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-22T07:15:10.940",
  "lastModified": "2024-11-21T06:36:11.843",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix data corruption after conversion from inline format\n\nCommit 6dbf7bb55598 (\"fs: Don't invalidate page buffers in\nblock_write_full_page()\") uncovered a latent bug in ocfs2 conversion\nfrom inline inode format to a normal inode format.\n\nThe code in ocfs2_convert_inline_data_to_extents() attempts to zero out\nthe whole cluster allocated for file data by grabbing, zeroing, and\ndirtying all pages covering this cluster.  However these pages are\nbeyond i_size, thus writeback code generally ignores these dirty pages\nand no blocks were ever actually zeroed on the disk.\n\nThis oversight was fixed by commit 693c241a5f6a (\"ocfs2: No need to zero\npages past i_size.\") for standard ocfs2 write path, inline conversion\npath was apparently forgotten; the commit log also has a reasoning why\nthe zeroing actually is not needed.\n\nAfter commit 6dbf7bb55598, things became worse as writeback code stopped\ninvalidating buffers on pages beyond i_size and thus these pages end up\nwith clean PageDirty bit but with buffers attached to these pages being\nstill dirty.  So when a file is converted from inline format, then\nwriteback triggers, and then the file is grown so that these pages\nbecome valid, the invalid dirtiness state is preserved,\nmark_buffer_dirty() does nothing on these pages (buffers are already\ndirty) but page is never written back because it is clean.  So data\nwritten to these pages is lost once pages are reclaimed.\n\nSimple reproducer for the problem is:\n\n  xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\\n    -c \"pwrite 4000 2000\" ocfs2_file\n\nAfter unmounting and mounting the fs again, you can observe that end of\n'ocfs2_file' has lost its contents.\n\nFix the problem by not doing the pointless zeroing during conversion\nfrom inline format similarly as in the standard write path.\n\n[akpm@linux-foundation.org: fix whitespace, per Joseph]"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ocfs2: corrige la corrupción de datos después de la conversión desde el formato en línea. el commit 6dbf7bb55598 (\"fs: No invalide los buffers de página en block_write_full_page()\") descubrió un error latente en la conversión de ocfs2 desde el inodo en línea. formato a un formato de inodo normal. El código en ocfs2_convert_inline_data_to_extents() intenta poner a cero todo el clúster asignado para datos de archivos capturando, poniendo a cero y ensuciando todas las páginas que cubren este clúster. Sin embargo, estas páginas están más allá de i_size, por lo que el código de reescritura generalmente ignora estas páginas sucias y nunca se puso a cero ningún bloque en el disco. Este descuido se solucionó mediante el commit 693c241a5f6a (\"ocfs2: No es necesario poner a cero las páginas después de i_size.\") para la ruta de escritura estándar de ocfs2, la ruta de conversión en línea aparentemente se olvidó; el registro de confirmación también tiene un razonamiento por el cual la puesta a cero en realidad no es necesaria. Después de el commit 6dbf7bb55598, las cosas empeoraron ya que el código de reescritura dejó de invalidar los buffers en páginas más allá de i_size y, por lo tanto, estas páginas terminan con un bit PageDirty limpio pero con los búferes adjuntos a estas páginas todavía sucios. Entonces, cuando un archivo se convierte desde un formato en línea, se activa la reescritura y luego el archivo crece para que estas páginas se vuelvan válidas, se conserva el estado de suciedad no válido, mark_buffer_dirty() no hace nada en estas páginas (los búferes ya están sucios), excepto la página nunca se vuelve a escribir porque está limpio. Por lo tanto, los datos escritos en estas páginas se pierden una vez que se recuperan las páginas. El reproductor simple para el problema es: xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\ -c \"pwrite 4000 2000\" ocfs2_file Después de desmontar y montar el fs nuevamente, puede observar que El final de 'ocfs2_file' ha perdido su contenido. Solucione el problema al no realizar la puesta a cero inútil durante la conversión desde el formato en línea de manera similar a como lo hace en la ruta de escritura estándar. [akpm@linux-foundation.org: arreglar espacios en blanco, según Joseph]"
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}