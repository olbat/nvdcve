{
  "id": "CVE-2025-38544",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-08-16T12:15:30.373",
  "lastModified": "2025-08-18T20:16:28.750",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix bug due to prealloc collision\n\nWhen userspace is using AF_RXRPC to provide a server, it has to preallocate\nincoming calls and assign to them call IDs that will be used to thread\nrelated recvmsg() and sendmsg() together.  The preallocated call IDs will\nautomatically be attached to calls as they come in until the pool is empty.\n\nTo the kernel, the call IDs are just arbitrary numbers, but userspace can\nuse the call ID to hold a pointer to prepared structs.  In any case, the\nuser isn't permitted to create two calls with the same call ID (call IDs\nbecome available again when the call ends) and EBADSLT should result from\nsendmsg() if an attempt is made to preallocate a call with an in-use call\nID.\n\nHowever, the cleanup in the error handling will trigger both assertions in\nrxrpc_cleanup_call() because the call isn't marked complete and isn't\nmarked as having been released.\n\nFix this by setting the call state in rxrpc_service_prealloc_one() and then\nmarking it as being released before calling the cleanup function."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rxrpc: Corrección de error debido a la colisión de preasignación Cuando el espacio de usuario usa AF_RXRPC para proporcionar un servidor, tiene que preasignar las llamadas entrantes y asignarles identificadores de llamada que se usarán para enhebrar recvmsg() y sendmsg() relacionados. Los identificadores de llamada preasignados se adjuntarán automáticamente a las llamadas a medida que entran hasta que el grupo esté vacío. Para el kernel, los identificadores de llamada son solo números arbitrarios, pero el espacio de usuario puede usar el identificador de llamada para contener un puntero a estructuras preparadas. En cualquier caso, el usuario no tiene permitido crear dos llamadas con el mismo identificador de llamada (los identificadores de llamada vuelven a estar disponibles cuando la llamada finaliza) y EBADSLT debería ser el resultado de sendmsg() si se intenta preasignar una llamada con un identificador de llamada en uso. Sin embargo, la limpieza en el manejo de errores activará ambas aserciones en rxrpc_cleanup_call() porque la llamada no está marcada como completa ni como liberada. Solucione esto configurando el estado de la llamada en rxrpc_service_prealloc_one() y luego marcándolo como liberado antes de llamar a la función de limpieza."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/432c5363cd6fe5a928bbc94524d28b05515684dd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5385ad53793de2ab11e396bdcdaa65bb04b4dad6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/69e4186773c6445b258fb45b6e1df18df831ec45",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d8ffb47a443919277cb093c3db1ec6c0a06880b1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}