{
  "id": "CVE-2024-57889",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-01-15T13:15:13.347",
  "lastModified": "2025-01-15T13:15:13.347",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: mcp23s08: Fix sleeping in atomic context due to regmap locking\n\nIf a device uses MCP23xxx IO expander to receive IRQs, the following\nbug can happen:\n\n  BUG: sleeping function called from invalid context\n    at kernel/locking/mutex.c:283\n  in_atomic(): 1, irqs_disabled(): 1, non_block: 0, ...\n  preempt_count: 1, expected: 0\n  ...\n  Call Trace:\n  ...\n  __might_resched+0x104/0x10e\n  __might_sleep+0x3e/0x62\n  mutex_lock+0x20/0x4c\n  regmap_lock_mutex+0x10/0x18\n  regmap_update_bits_base+0x2c/0x66\n  mcp23s08_irq_set_type+0x1ae/0x1d6\n  __irq_set_trigger+0x56/0x172\n  __setup_irq+0x1e6/0x646\n  request_threaded_irq+0xb6/0x160\n  ...\n\nWe observed the problem while experimenting with a touchscreen driver which\nused MCP23017 IO expander (I2C).\n\nThe regmap in the pinctrl-mcp23s08 driver uses a mutex for protection from\nconcurrent accesses, which is the default for regmaps without .fast_io,\n.disable_locking, etc.\n\nmcp23s08_irq_set_type() calls regmap_update_bits_base(), and the latter\nlocks the mutex.\n\nHowever, __setup_irq() locks desc->lock spinlock before calling these\nfunctions. As a result, the system tries to lock the mutex whole holding\nthe spinlock.\n\nIt seems, the internal regmap locks are not needed in this driver at all.\nmcp->lock seems to protect the regmap from concurrent accesses already,\nexcept, probably, in mcp_pinconf_get/set.\n\nmcp23s08_irq_set_type() and mcp23s08_irq_mask/unmask() are called under\nchip_bus_lock(), which calls mcp23s08_irq_bus_lock(). The latter takes\nmcp->lock and enables regmap caching, so that the potentially slow I2C\naccesses are deferred until chip_bus_unlock().\n\nThe accesses to the regmap from mcp23s08_probe_one() do not need additional\nlocking.\n\nIn all remaining places where the regmap is accessed, except\nmcp_pinconf_get/set(), the driver already takes mcp->lock.\n\nThis patch adds locking in mcp_pinconf_get/set() and disables internal\nlocking in the regmap config. Among other things, it fixes the sleeping\nin atomic context described above."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: pinctrl: mcp23s08: Se corrige la suspensión en un contexto atómico debido al bloqueo de regmap Si un dispositivo usa el expansor de E/S MCP23xxx para recibir IRQ, puede ocurrir el siguiente error: ERROR: función de suspensión llamada desde un contexto no válido en kernel/locking/mutex.c:283 in_atomic(): 1, irqs_disabled(): 1, non_block: 0, ... preempt_count: 1, expected: 0 ... Seguimiento de llamadas: ... __might_resched+0x104/0x10e __might_sleep+0x3e/0x62 mutex_lock+0x20/0x4c regmap_lock_mutex+0x10/0x18 regmap_update_bits_base+0x2c/0x66 Observamos el problema mientras experimentábamos con un controlador de pantalla táctil que usaba el expansor de E/S MCP23017 (I2C). El mapa de reglas en el controlador pinctrl-mcp23s08 usa un mutex para protección contra accesos concurrentes, que es el valor predeterminado para los mapas de reglas sin .fast_io, .disable_locking, etc. mcp23s08_irq_set_type() llama a regmap_update_bits_base(), y este último bloquea el mutex. Sin embargo, __setup_irq() bloquea el spinlock desc-&gt;lock antes de llamar a estas funciones. Como resultado, el sistema intenta bloquear el mutex que contiene el spinlock. Parece que los bloqueos internos del mapa de reglas no son necesarios en este controlador en absoluto. mcp-&gt;lock parece proteger el mapa de reglas de accesos concurrentes, excepto, probablemente, en mcp_pinconf_get/set. mcp23s08_irq_set_type() y mcp23s08_irq_mask/unmask() se llaman bajo chip_bus_lock(), que llama a mcp23s08_irq_bus_lock(). Este último toma mcp-&gt;lock y habilita el almacenamiento en caché del mapa de reglas, de modo que los accesos I2C potencialmente lentos se posponen hasta chip_bus_unlock(). Los accesos al mapa de reglas desde mcp23s08_probe_one() no necesitan bloqueo adicional. En todos los lugares restantes donde se accede al mapa de reglas, excepto mcp_pinconf_get/set(), el controlador ya toma mcp-&gt;lock. Este parche agrega bloqueo en mcp_pinconf_get/set() y deshabilita el bloqueo interno en la configuración de regmap. Entre otras cosas, corrige el problema de suspensión en el contexto atómico descrito anteriormente."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0310cbad163a908d09d99c26827859365cd71fcb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/788d9e9a41b81893d6bb8faa05f045c975278318",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/830f838589522404cd7c2f0f540602f25034af61",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8c6fd5803b988a5e78c9b9e42c70a936d7cfc6ec",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9372e160d8211a7e17f2abff8370794f182df785",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a37eecb705f33726f1fb7cd2a67e514a15dfe693",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c55d186376a87b468c9ee30f2195e0f3857f61a0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}