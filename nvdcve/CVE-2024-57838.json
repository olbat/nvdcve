{
  "id": "CVE-2024-57838",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-01-11T14:15:25.940",
  "lastModified": "2025-01-11T14:15:25.940",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/entry: Mark IRQ entries to fix stack depot warnings\n\nThe stack depot filters out everything outside of the top interrupt\ncontext as an uninteresting or irrelevant part of the stack traces. This\nhelps with stack trace de-duplication, avoiding an explosion of saved\nstack traces that share the same IRQ context code path but originate\nfrom different randomly interrupted points, eventually exhausting the\nstack depot.\n\nFiltering uses in_irqentry_text() to identify functions within the\n.irqentry.text and .softirqentry.text sections, which then become the\nlast stack trace entries being saved.\n\nWhile __do_softirq() is placed into the .softirqentry.text section by\ncommon code, populating .irqentry.text is architecture-specific.\n\nCurrently, the .irqentry.text section on s390 is empty, which prevents\nstack depot filtering and de-duplication and could result in warnings\nlike:\n\nStack depot reached limit capacity\nWARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8\n\nwith PREEMPT and KASAN enabled.\n\nFix this by moving the IO/EXT interrupt handlers from .kprobes.text into\nthe .irqentry.text section and updating the kprobes blacklist to include\nthe .irqentry.text section.\n\nThis is done only for asynchronous interrupts and explicitly not for\nprogram checks, which are synchronous and where the context beyond the\nprogram check is important to preserve. Despite machine checks being\nsomewhat in between, they are extremely rare, and preserving context\nwhen possible is also of value.\n\nSVCs and Restart Interrupts are not relevant, one being always at the\nboundary to user space and the other being a one-time thing.\n\nIRQ entries filtering is also optionally used in ftrace function graph,\nwhere the same logic applies."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: s390/entry: Marcar entradas de IRQ para corregir advertencias del depósito de pila El depósito de pila filtra todo lo que esté fuera del contexto de interrupción superior como una parte poco interesante o irrelevante de los seguimientos de pila. Esto ayuda con la desduplicación del seguimiento de pila, evitando una explosión de seguimientos de pila guardados que comparten la misma ruta de código de contexto de IRQ pero que se originan en diferentes puntos interrumpidos aleatoriamente, agotando eventualmente el depósito de pila. El filtrado utiliza in_irqentry_text() para identificar funciones dentro de las secciones .irqentry.text y .softirqentry.text, que luego se convierten en las últimas entradas del seguimiento de pila que se guardan. Si bien __do_softirq() se coloca en la sección .softirqentry.text por código común, completar .irqentry.text es específico de la arquitectura. Actualmente, la sección .irqentry.text en s390 está vacía, lo que impide el filtrado y la deduplicación del depósito de pila y podría generar advertencias como: El depósito de pila alcanzó la capacidad límite ADVERTENCIA: CPU: 0 PID: 286113 en lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8 con PREEMPT y KASAN habilitados. Solucione esto moviendo los controladores de interrupción IO/EXT de .kprobes.text a la sección .irqentry.text y actualizando la lista negra de kprobes para incluir la sección .irqentry.text. Esto se hace solo para interrupciones asincrónicas y explícitamente no para verificaciones de programa, que son sincrónicas y donde es importante preservar el contexto más allá de la verificación de programa. A pesar de que las verificaciones de máquina están algo en el medio, son extremadamente raras y preservar el contexto cuando sea posible también es valioso. Los SVC y las interrupciones de reinicio no son relevantes, uno siempre se encuentra en el límite del espacio del usuario y el otro es algo que ocurre una sola vez. El filtrado de entradas IRQ también se utiliza de manera opcional en el gráfico de funciones ftrace, donde se aplica la misma lógica."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1af22528fee8072b7adc007b8ca49cc4ea62689e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/45c9f2b856a075a34873d00788d2e8a250c1effd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/473ffae3030188f1c6b80e1b3631a26b4adf7b32",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5bb7a2c3afcf8732dc65ea49c09147b07da1d993",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ca687fdce5b95f84d91d6e36ac77047771eb3dfc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}