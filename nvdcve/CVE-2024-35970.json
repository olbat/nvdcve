{
  "id": "CVE-2024-35970",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-20T10:15:11.860",
  "lastModified": "2025-04-04T14:45:14.893",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Clear stale u->oob_skb.\n\nsyzkaller started to report deadlock of unix_gc_lock after commit\n4090fa373f0e (\"af_unix: Replace garbage collection algorithm.\"), but\nit just uncovers the bug that has been there since commit 314001f0bf92\n(\"af_unix: Add OOB support\").\n\nThe repro basically does the following.\n\n  from socket import *\n  from array import array\n\n  c1, c2 = socketpair(AF_UNIX, SOCK_STREAM)\n  c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS, array(\"i\", [c2.fileno()]))], MSG_OOB)\n  c2.recv(1)  # blocked as no normal data in recv queue\n\n  c2.close()  # done async and unblock recv()\n  c1.close()  # done async and trigger GC\n\nA socket sends its file descriptor to itself as OOB data and tries to\nreceive normal data, but finally recv() fails due to async close().\n\nThe problem here is wrong handling of OOB skb in manage_oob().  When\nrecvmsg() is called without MSG_OOB, manage_oob() is called to check\nif the peeked skb is OOB skb.  In such a case, manage_oob() pops it\nout of the receive queue but does not clear unix_sock(sk)->oob_skb.\nThis is wrong in terms of uAPI.\n\nLet's say we send \"hello\" with MSG_OOB, and \"world\" without MSG_OOB.\nThe 'o' is handled as OOB data.  When recv() is called twice without\nMSG_OOB, the OOB data should be lost.\n\n  >>> from socket import *\n  >>> c1, c2 = socketpair(AF_UNIX, SOCK_STREAM, 0)\n  >>> c1.send(b'hello', MSG_OOB)  # 'o' is OOB data\n  5\n  >>> c1.send(b'world')\n  5\n  >>> c2.recv(5)  # OOB data is not received\n  b'hell'\n  >>> c2.recv(5)  # OOB date is skipped\n  b'world'\n  >>> c2.recv(5, MSG_OOB)  # This should return an error\n  b'o'\n\nIn the same situation, TCP actually returns -EINVAL for the last\nrecv().\n\nAlso, if we do not clear unix_sk(sk)->oob_skb, unix_poll() always set\nEPOLLPRI even though the data has passed through by previous recv().\n\nTo avoid these issues, we must clear unix_sk(sk)->oob_skb when dequeuing\nit from recv queue.\n\nThe reason why the old GC did not trigger the deadlock is because the\nold GC relied on the receive queue to detect the loop.\n\nWhen it is triggered, the socket with OOB data is marked as GC candidate\nbecause file refcount == inflight count (1).  However, after traversing\nall inflight sockets, the socket still has a positive inflight count (1),\nthus the socket is excluded from candidates.  Then, the old GC lose the\nchance to garbage-collect the socket.\n\nWith the old GC, the repro continues to create true garbage that will\nnever be freed nor detected by kmemleak as it's linked to the global\ninflight list.  That's why we couldn't even notice the issue."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: af_unix: Borrar u-&gt;oob_skb obsoleto. syzkaller comenzó a informar un punto muerto de unix_gc_lock después de la confirmación 4090fa373f0e (\"af_unix: Reemplazar el algoritmo de recolección de basura\"), pero simplemente descubre el error que ha estado ahí desde la confirmación 314001f0bf92 (\"af_unix: Agregar soporte OOB\"). La reproducción básicamente hace lo siguiente. desde importación de socket * desde matriz de importación matriz c1, c2 = socketpair(AF_UNIX, SOCK_STREAM) c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS, array(\"i\", [c2.fileno()])) ], MSG_OOB) c2.recv(1) # bloqueado porque no hay datos normales en la cola de recepción c2.close() # hecho asíncrono y desbloquea recv() c1.close() # hecho asíncrono y activa GC Un socket envía su descriptor de archivo a como datos OOB e intenta recibir datos normales, pero finalmente recv() falla debido al cierre asíncrono(). El problema aquí es el manejo incorrecto de OOB skb en Manage_oob(). Cuando se llama a recvmsg() sin MSG_OOB, se llama a Manage_oob() para verificar si el skb visto es skb OOB. En tal caso, Manage_oob() lo saca de la cola de recepción pero no borra unix_sock(sk)-&gt;oob_skb. Esto está mal en términos de uAPI. Digamos que enviamos \"hola\" con MSG_OOB y \"mundo\" sin MSG_OOB. La 'o' se maneja como datos OOB. Cuando se llama a recv() dos veces sin MSG_OOB, los datos OOB deberían perderse. &gt;&gt;&gt; desde importación de socket * &gt;&gt;&gt; c1, c2 = socketpair(AF_UNIX, SOCK_STREAM, 0) &gt;&gt;&gt; c1.send(b'hello', MSG_OOB) # 'o' son datos OOB 5 &gt;&gt;&gt; c1.send (b'world') 5 &gt;&gt;&gt; c2.recv(5) # Los datos OOB no se reciben b'hell' &gt;&gt;&gt; c2.recv(5) # La fecha OOB se omite b'world' &gt;&gt;&gt; c2.recv (5, MSG_OOB) # Esto debería devolver un error b'o'. En la misma situación, TCP en realidad devuelve -EINVAL para el último recv(). Además, si no borramos unix_sk(sk)-&gt;oob_skb, unix_poll() siempre establece EPOLLPRI aunque los datos hayan pasado por el recv() anterior. Para evitar estos problemas, debemos borrar unix_sk(sk)-&gt;oob_skb al retirarlo de la cola de recepción. La razón por la que el antiguo GC no provocó el punto muerto es porque el antiguo GC dependía de la cola de recepción para detectar el bucle. Cuando se activa, el socket con datos OOB se marca como candidato de GC porque el recuento de archivos == recuento en vuelo (1). Sin embargo, después de atravesar todos los sockets en vuelo, el socket todavía tiene un recuento positivo en vuelo (1), por lo que el socket queda excluido de los candidatos. Entonces, el antiguo GC pierde la oportunidad de recolectar basura en el socket. Con el antiguo GC, la reproducción continúa creando verdadera basura que kmemleak nunca liberará ni detectará, ya que está vinculada a la lista global a bordo. Por eso ni siquiera pudimos notar el problema."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
        "type": "Secondary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L",
          "baseScore": 6.3,
          "baseSeverity": "MEDIUM",
          "attackVector": "NETWORK",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "LOW",
          "integrityImpact": "LOW",
          "availabilityImpact": "LOW"
        },
        "exploitabilityScore": 2.8,
        "impactScore": 3.4
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-667"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.15",
              "versionEndExcluding": "5.15.156",
              "matchCriteriaId": "0A40A9D8-C388-43D1-AA37-C61111EB1774"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.16",
              "versionEndExcluding": "6.1.87",
              "matchCriteriaId": "BDA59296-EDB8-44CD-98E4-C08C051569E6"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.2",
              "versionEndExcluding": "6.6.28",
              "matchCriteriaId": "8D6315B0-B3BA-406C-B0DB-51D9A63753F0"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.7",
              "versionEndExcluding": "6.8.7",
              "matchCriteriaId": "531BDFB5-EF6A-4707-902E-146368303499"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.9:rc1:*:*:*:*:*:*",
              "matchCriteriaId": "22BEDD49-2C6D-402D-9DBF-6646F6ECD10B"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.9:rc2:*:*:*:*:*:*",
              "matchCriteriaId": "DF73CB2A-DFFD-46FB-9BFE-AA394F27EA37"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.9:rc3:*:*:*:*:*:*",
              "matchCriteriaId": "52048DDA-FC5A-4363-95A0-A6357B4D7F8C"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/601a89ea24d05089debfa2dc896ea9f5937ac7a6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/698a95ade1a00e6494482046902b986dfffd1caf",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/84a352b7eba1142a95441380058985ff19f25ec9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/b46f4eaa4f0ec38909fb0072eea3aeddb32f954e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/b4bc99d04c689b5652665394ae8d3e02fb754153",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/601a89ea24d05089debfa2dc896ea9f5937ac7a6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/698a95ade1a00e6494482046902b986dfffd1caf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/84a352b7eba1142a95441380058985ff19f25ec9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/b46f4eaa4f0ec38909fb0072eea3aeddb32f954e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/b4bc99d04c689b5652665394ae8d3e02fb754153",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ]
}