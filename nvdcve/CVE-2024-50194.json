{
  "id": "CVE-2024-50194",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-11-08T06:15:16.217",
  "lastModified": "2024-11-29T19:33:26.060",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: probes: Fix uprobes for big-endian kernels\n\nThe arm64 uprobes code is broken for big-endian kernels as it doesn't\nconvert the in-memory instruction encoding (which is always\nlittle-endian) into the kernel's native endianness before analyzing and\nsimulating instructions. This may result in a few distinct problems:\n\n* The kernel may may erroneously reject probing an instruction which can\n  safely be probed.\n\n* The kernel may erroneously erroneously permit stepping an\n  instruction out-of-line when that instruction cannot be stepped\n  out-of-line safely.\n\n* The kernel may erroneously simulate instruction incorrectly dur to\n  interpretting the byte-swapped encoding.\n\nThe endianness mismatch isn't caught by the compiler or sparse because:\n\n* The arch_uprobe::{insn,ixol} fields are encoded as arrays of u8, so\n  the compiler and sparse have no idea these contain a little-endian\n  32-bit value. The core uprobes code populates these with a memcpy()\n  which similarly does not handle endianness.\n\n* While the uprobe_opcode_t type is an alias for __le32, both\n  arch_uprobe_analyze_insn() and arch_uprobe_skip_sstep() cast from u8[]\n  to the similarly-named probe_opcode_t, which is an alias for u32.\n  Hence there is no endianness conversion warning.\n\nFix this by changing the arch_uprobe::{insn,ixol} fields to __le32 and\nadding the appropriate __le32_to_cpu() conversions prior to consuming\nthe instruction encoding. The core uprobes copies these fields as opaque\nranges of bytes, and so is unaffected by this change.\n\nAt the same time, remove MAX_UINSN_BYTES and consistently use\nAARCH64_INSN_SIZE for clarity.\n\nTested with the following:\n\n| #include <stdio.h>\n| #include <stdbool.h>\n|\n| #define noinline __attribute__((noinline))\n|\n| static noinline void *adrp_self(void)\n| {\n|         void *addr;\n|\n|         asm volatile(\n|         \"       adrp    %x0, adrp_self\\n\"\n|         \"       add     %x0, %x0, :lo12:adrp_self\\n\"\n|         : \"=r\" (addr));\n| }\n|\n|\n| int main(int argc, char *argv)\n| {\n|         void *ptr = adrp_self();\n|         bool equal = (ptr == adrp_self);\n|\n|         printf(\"adrp_self   => %p\\n\"\n|                \"adrp_self() => %p\\n\"\n|                \"%s\\n\",\n|                adrp_self, ptr, equal ? \"EQUAL\" : \"NOT EQUAL\");\n|\n|         return 0;\n| }\n\n.... where the adrp_self() function was compiled to:\n\n| 00000000004007e0 <adrp_self>:\n|   4007e0:       90000000        adrp    x0, 400000 <__ehdr_start>\n|   4007e4:       911f8000        add     x0, x0, #0x7e0\n|   4007e8:       d65f03c0        ret\n\nBefore this patch, the ADRP is not recognized, and is assumed to be\nsteppable, resulting in corruption of the result:\n\n| # ./adrp-self\n| adrp_self   => 0x4007e0\n| adrp_self() => 0x4007e0\n| EQUAL\n| # echo 'p /root/adrp-self:0x007e0' > /sys/kernel/tracing/uprobe_events\n| # echo 1 > /sys/kernel/tracing/events/uprobes/enable\n| # ./adrp-self\n| adrp_self   => 0x4007e0\n| adrp_self() => 0xffffffffff7e0\n| NOT EQUAL\n\nAfter this patch, the ADRP is correctly recognized and simulated:\n\n| # ./adrp-self\n| adrp_self   => 0x4007e0\n| adrp_self() => 0x4007e0\n| EQUAL\n| #\n| # echo 'p /root/adrp-self:0x007e0' > /sys/kernel/tracing/uprobe_events\n| # echo 1 > /sys/kernel/tracing/events/uprobes/enable\n| # ./adrp-self\n| adrp_self   => 0x4007e0\n| adrp_self() => 0x4007e0\n| EQUAL"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: arm64: sondas: corrige uprobes para kernels big-endian El código de uprobes de arm64 está roto para kernels big-endian ya que no convierte la codificación de instrucciones en memoria (que siempre es little-endian) al endianness nativo del kernel antes de analizar y simular instrucciones. Esto puede resultar en algunos problemas distintos: * El kernel puede rechazar erróneamente el sondeo de una instrucción que puede sondearse de forma segura. * El kernel puede permitir erróneamente el paso de una instrucción fuera de línea cuando esa instrucción no puede ser pasada fuera de línea de forma segura. * El kernel puede simular erróneamente la instrucción incorrectamente durante la interpretación de la codificación de bytes intercambiados. El desajuste de endianness no es detectado por el compilador o sparse porque: * Los campos arch_uprobe::{insn,ixol} están codificados como matrices de u8, por lo que el compilador y sparse no tienen idea de que estos contienen un valor de 32 bits little-endian. El código central de uprobes los llena con un memcpy() que de manera similar no maneja el endianness. * Si bien el tipo uprobe_opcode_t es un alias para __le32, tanto arch_uprobe_analyze_insn() como arch_uprobe_skip_sstep() convierten de u8[] al tipo de nombre similar probe_opcode_t, que es un alias para u32. Por lo tanto, no hay una advertencia de conversión de endianness. Solucione esto cambiando los campos arch_uprobe::{insn,ixol} a __le32 y agregando las conversiones __le32_to_cpu() apropiadas antes de consumir la codificación de instrucciones. El núcleo uprobes copia estos campos como rangos opacos de bytes y, por lo tanto, no se ve afectado por este cambio. Al mismo tiempo, elimine MAX_UINSN_BYTES y use consistentemente AARCH64_INSN_SIZE para mayor claridad. Probado con lo siguiente: | #include  | #include  | | #define noinline __attribute__((noinline)) | | static noinline void *adrp_self(void) | { | void *addr; | | asm volátil( | \" adrp %x0, adrp_self\\n\" | \" add %x0, %x0, :lo12:adrp_self\\n\" | : \"=r\" (addr)); | } | | | int main(int argc, char *argv) | { | void *ptr = adrp_self(); | bool equal = (ptr == adrp_self); | | printf(\"adrp_self =&gt; %p\\n\" | \"adrp_self() =&gt; %p\\n\" | \"%s\\n\", | adrp_self, ptr, equal ? \"EQUAL\" : \"NOT EQUAL\"); | | return 0; | } .... donde la función adrp_self() se compiló a: | 00000000004007e0 : | 4007e0: 90000000 adrp x0, 400000 &lt;__ehdr_start&gt; | 4007e4: 911f8000 add x0, x0, #0x7e0 | 4007e8: d65f03c0 ret Antes de este parche, no se reconocía el ADRP y se asumía que se podía ejecutar paso a paso, lo que provocaba la corrupción del resultado: | # ./adrp-self | adrp_self =&gt; 0x4007e0 | adrp_self() =&gt; 0x4007e0 | IGUAL | # echo 'p /root/adrp-self:0x007e0' &gt; /sys/kernel/tracing/uprobe_events | # echo 1 &gt; /sys/kernel/tracing/events/uprobes/enable | # ./adrp-self | adrp_self =&gt; 0x4007e0 | adrp_self() =&gt; 0xffffffffff7e0 | NO IGUAL Después de este parche, el ADRP se reconoce y simula correctamente: | # ./adrp-self | adrp_self =&gt; 0x4007e0 | adrp_self() =&gt; 0x4007e0 | IGUAL | # | # echo 'p /root/adrp-self:0x007e0' &gt; /sys/kernel/tracing/uprobe_events | # echo 1 &gt; /sys/kernel/tracing/events/uprobes/enable | # ./adrp-self | adrp_self =&gt; 0x4007e0 | adrp_self() =&gt; 0x4007e0 | IGUAL"
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "NVD-CWE-noinfo"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "4.10",
              "versionEndExcluding": "4.19.323",
              "matchCriteriaId": "56700326-E491-4B17-B143-B939C5EC1DBE"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "4.20",
              "versionEndExcluding": "5.4.285",
              "matchCriteriaId": "B5A89369-320F-47FC-8695-56F61F87E4C0"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.5",
              "versionEndExcluding": "5.10.229",
              "matchCriteriaId": "1A03CABE-9B43-4E7F-951F-10DEEADAA426"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.11",
              "versionEndExcluding": "5.15.170",
              "matchCriteriaId": "A9BA1C73-2D2E-45E3-937B-276A28AEB5FC"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.16",
              "versionEndExcluding": "6.1.115",
              "matchCriteriaId": "C08A77A6-E42E-4EFD-B5A1-2BF6CBBB42AE"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.2",
              "versionEndExcluding": "6.6.58",
              "matchCriteriaId": "6B9489BC-825E-4EEE-8D93-F93C801988C8"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.7",
              "versionEndExcluding": "6.11.5",
              "matchCriteriaId": "6E62D61A-F704-44DB-A311-17B7534DA7BC"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*",
              "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*",
              "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*",
              "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/13f8f1e05f1dc36dbba6cba0ae03354c0dafcde7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/14841bb7a531b96e2dde37423a3b33e75147c60d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/3d2530c65be04e93720e30f191a7cf1a3aa8b51c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/8165bf83b8a64be801d59cd2532b0d1ffed74d00",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/b6a638cb600e13f94b5464724eaa6ab7f3349ca2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/cf60d19d40184e43d9a624e55a0da73be09e938d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/cf9ddf9ed94c15564a05bbf6e9f18dffa0c7df80",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/e6ab336213918575124d6db43dc5d3554526242e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}