{
  "id": "CVE-2021-47011",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-02-28T09:15:38.703",
  "lastModified": "2025-01-08T18:02:38.837",
  "vulnStatus": "Analyzed",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: memcontrol: slab: fix obtain a reference to a freeing memcg\n\nPatch series \"Use obj_cgroup APIs to charge kmem pages\", v5.\n\nSince Roman's series \"The new cgroup slab memory controller\" applied.\nAll slab objects are charged with the new APIs of obj_cgroup.  The new\nAPIs introduce a struct obj_cgroup to charge slab objects.  It prevents\nlong-living objects from pinning the original memory cgroup in the\nmemory.  But there are still some corner objects (e.g.  allocations\nlarger than order-1 page on SLUB) which are not charged with the new\nAPIs.  Those objects (include the pages which are allocated from buddy\nallocator directly) are charged as kmem pages which still hold a\nreference to the memory cgroup.\n\nE.g.  We know that the kernel stack is charged as kmem pages because the\nsize of the kernel stack can be greater than 2 pages (e.g.  16KB on\nx86_64 or arm64).  If we create a thread (suppose the thread stack is\ncharged to memory cgroup A) and then move it from memory cgroup A to\nmemory cgroup B.  Because the kernel stack of the thread hold a\nreference to the memory cgroup A.  The thread can pin the memory cgroup\nA in the memory even if we remove the cgroup A.  If we want to see this\nscenario by using the following script.  We can see that the system has\nadded 500 dying cgroups (This is not a real world issue, just a script\nto show that the large kmallocs are charged as kmem pages which can pin\nthe memory cgroup in the memory).\n\n\t#!/bin/bash\n\n\tcat /proc/cgroups | grep memory\n\n\tcd /sys/fs/cgroup/memory\n\techo 1 > memory.move_charge_at_immigrate\n\n\tfor i in range{1..500}\n\tdo\n\t\tmkdir kmem_test\n\t\techo $$ > kmem_test/cgroup.procs\n\t\tsleep 3600 &\n\t\techo $$ > cgroup.procs\n\t\techo `cat kmem_test/cgroup.procs` > cgroup.procs\n\t\trmdir kmem_test\n\tdone\n\n\tcat /proc/cgroups | grep memory\n\nThis patchset aims to make those kmem pages to drop the reference to\nmemory cgroup by using the APIs of obj_cgroup.  Finally, we can see that\nthe number of the dying cgroups will not increase if we run the above test\nscript.\n\nThis patch (of 7):\n\nThe rcu_read_lock/unlock only can guarantee that the memcg will not be\nfreed, but it cannot guarantee the success of css_get (which is in the\nrefill_stock when cached memcg changed) to memcg.\n\n  rcu_read_lock()\n  memcg = obj_cgroup_memcg(old)\n  __memcg_kmem_uncharge(memcg)\n      refill_stock(memcg)\n          if (stock->cached != memcg)\n              // css_get can change the ref counter from 0 back to 1.\n              css_get(&memcg->css)\n  rcu_read_unlock()\n\nThis fix is very like the commit:\n\n  eefbfa7fd678 (\"mm: memcg/slab: fix use after free in obj_cgroup_charge\")\n\nFix this by holding a reference to the memcg which is passed to the\n__memcg_kmem_uncharge() before calling __memcg_kmem_uncharge()."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: memcontrol: slab: fix obtener una referencia a una serie de parches de liberación de memcg \"Utilice las API de obj_cgroup para cargar páginas kmem\", v5. Desde que se aplicó la serie de Roman \"El nuevo controlador de memoria losa de cgroup\". Todos los objetos de losa se cargan con las nuevas API de obj_cgroup. Las nuevas API introducen una estructura obj_cgroup para cargar objetos de losa. Evita que los objetos de larga duración fijen el grupo de memoria original en la memoria. Pero todavía hay algunos objetos de esquina (por ejemplo, asignaciones mayores que la página de pedido 1 en SLUB) que no se cargan con las nuevas API. Esos objetos (incluidas las páginas que se asignan directamente desde el asignador de amigos) se cargan como páginas kmem que aún contienen una referencia al grupo de memoria. Por ejemplo, sabemos que la pila del kernel se carga como páginas kmem porque el tamaño de la pila del kernel puede ser mayor que 2 páginas (por ejemplo, 16 KB en x86_64 o arm64). Si creamos un subproceso (supongamos que la pila de subprocesos se carga en el grupo c de memoria A) y luego lo movemos del grupo c de memoria A al grupo c de memoria B. Porque la pila del núcleo del subproceso contiene una referencia al grupo c de memoria A. El hilo puede anclar la memoria cgroup A en la memoria incluso si eliminamos el cgroup A. Si queremos ver este escenario usando el siguiente script. Podemos ver que el sistema ha agregado 500 cgroups moribundos (esto no es un problema del mundo real, solo un script para mostrar que los kmallocs grandes se cargan como páginas kmem que pueden fijar el cgroup de memoria en la memoria). #!/bin/bash cat /proc/cgroups | grep memoria cd /sys/fs/cgroup/memory echo 1 &gt; memoria.move_charge_at_immigrate para i en el rango{1..500} hacer mkdir kmem_test echo $$ &gt; kmem_test/cgroup.procs sleep 3600 &amp; echo $$ &gt; cgroup.procs echo `cat kmem_test/cgroup.procs` &gt; cgroup.procs rmdir kmem_test hecho cat /proc/cgroups | grep memoria Este conjunto de parches tiene como objetivo hacer que esas páginas kmem eliminen la referencia a la memoria cgroup mediante el uso de las API de obj_cgroup. Finalmente, podemos ver que el número de cgroups moribundos no aumentará si ejecutamos el script de prueba anterior. Este parche (de 7): rcu_read_lock/unlock solo puede garantizar que el memcg no se libere, pero no puede garantizar el éxito de css_get (que está en refill_stock cuando se cambia el memcg en caché) a memcg. rcu_read_lock() memcg = obj_cgroup_memcg(old) __memcg_kmem_uncharge(memcg) refill_stock(memcg) if (stock-&gt;cached != memcg) // css_get puede cambiar el contador de referencia de 0 a 1. css_get(&amp;memcg-&gt;css) rcu_read_unlock( ) Esta solución es muy parecida a el commit: eefbfa7fd678 (\"mm: memcg/slab: fix use after free in obj_cgroup_charge\") Solucione este problema manteniendo una referencia al memcg que se pasa a __memcg_kmem_uncharge() antes de llamar a __memcg_kmem_uncharge()."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "NVD-CWE-noinfo"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.10.11",
              "versionEndExcluding": "5.10.37",
              "matchCriteriaId": "EDC4144D-717D-43A1-8F8D-FE6FC95AF795"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.11",
              "versionEndExcluding": "5.11.21",
              "matchCriteriaId": "8CBB94EC-EC33-4464-99C5-03E5542715F0"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.12",
              "versionEndExcluding": "5.12.4",
              "matchCriteriaId": "D8C7052F-1B7B-4327-9C2B-84EBF3243838"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/31df8bc4d3feca9f9c6b2cd06fd64a111ae1a0e6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/89b1ed358e01e1b0417f5d3b0082359a23355552",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/9f38f03ae8d5f57371b71aa6b4275765b65454fd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/c3ae6a3f3ca4f02f6ccddf213c027302586580d0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/31df8bc4d3feca9f9c6b2cd06fd64a111ae1a0e6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/89b1ed358e01e1b0417f5d3b0082359a23355552",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/9f38f03ae8d5f57371b71aa6b4275765b65454fd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/c3ae6a3f3ca4f02f6ccddf213c027302586580d0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ]
}