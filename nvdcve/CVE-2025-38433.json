{
  "id": "CVE-2025-38433",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-25T15:15:28.570",
  "lastModified": "2025-07-25T15:29:19.837",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: fix runtime constant support for nommu kernels\n\nthe `__runtime_fixup_32` function does not handle the case where `val` is\nzero correctly (as might occur when patching a nommu kernel and referring\nto a physical address below the 4GiB boundary whose upper 32 bits are all\nzero) because nothing in the existing logic prevents the code from taking\nthe `else` branch of both nop-checks and emitting two `nop` instructions.\n\nThis leaves random garbage in the register that is supposed to receive the\nupper 32 bits of the pointer instead of zero that when combined with the\nvalue for the lower 32 bits yields an invalid pointer and causes a kernel\npanic when that pointer is eventually accessed.\n\nThe author clearly considered the fact that if the `lui` is converted into\na `nop` that the second instruction needs to be adjusted to become an `li`\ninstead of an `addi`, hence introducing the `addi_insn_mask` variable, but\ndidn't follow that logic through fully to the case where the `else` branch\nexecutes. To fix it just adjust the logic to ensure that the second `else`\nbranch is not taken if the first instruction will be patched to a `nop`."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: riscv: se corrige el soporte de constantes de tiempo de ejecución para kernels nommu la función `__runtime_fixup_32` no maneja el caso donde `val` es cero correctamente (como podría ocurrir al parchar un kernel nommu y hacer referencia a una dirección física por debajo del límite de 4GiB cuyos 32 bits superiores son todos cero) porque nada en la lógica existente evita que el código tome la rama `else` de ambos nop-checks y emita dos instrucciones `nop`. Esto deja basura aleatoria en el registro que se supone que recibe los 32 bits superiores del puntero en lugar de cero que, cuando se combina con el valor de los 32 bits inferiores, produce un puntero no válido y causa un pánico del kernel cuando finalmente se accede a ese puntero. El autor consideró claramente que si la instrucción `lui` se convierte en `nop`, la segunda instrucción debe ajustarse para que se convierta en `li` en lugar de `addi`, introduciendo así la variable `addi_insn_mask`. Sin embargo, no siguió esta lógica completamente hasta el caso en que se ejecuta la rama `else`. Para solucionarlo, simplemente ajuste la lógica para garantizar que la segunda rama `else` no se ejecute si la primera instrucción se convierte en `nop`."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0a24b00dcde83934a3cc13e4c6b775522903496b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8d90d9872edae7e78c3a12b98e239bfaa66f3639",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}