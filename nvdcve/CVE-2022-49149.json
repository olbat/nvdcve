{
  "id": "CVE-2022-49149",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:00:52.073",
  "lastModified": "2025-02-26T07:00:52.073",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix call timer start racing with call destruction\n\nThe rxrpc_call struct has a timer used to handle various timed events\nrelating to a call.  This timer can get started from the packet input\nroutines that are run in softirq mode with just the RCU read lock held.\nUnfortunately, because only the RCU read lock is held - and neither ref or\nother lock is taken - the call can start getting destroyed at the same time\na packet comes in addressed to that call.  This causes the timer - which\nwas already stopped - to get restarted.  Later, the timer dispatch code may\nthen oops if the timer got deallocated first.\n\nFix this by trying to take a ref on the rxrpc_call struct and, if\nsuccessful, passing that ref along to the timer.  If the timer was already\nrunning, the ref is discarded.\n\nThe timer completion routine can then pass the ref along to the call's work\nitem when it queues it.  If the timer or work item where already\nqueued/running, the extra ref is discarded."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rxrpc: Se soluciona el inicio del temporizador de llamadas con la destrucción de llamadas La estructura rxrpc_call tiene un temporizador que se utiliza para gestionar varios eventos temporizados relacionados con una llamada. Este temporizador puede iniciarse desde las rutinas de entrada de paquetes que se ejecutan en modo softirq con solo el bloqueo de lectura RCU mantenido. Desafortunadamente, debido a que solo se mantiene el bloqueo de lectura RCU, y no se toma ninguna referencia ni ningún otro bloqueo, la llamada puede comenzar a destruirse al mismo tiempo que llega un paquete dirigido a esa llamada. Esto hace que el temporizador, que ya estaba detenido, se reinicie. Más tarde, el código de despacho del temporizador puede fallar si el temporizador se desasignó primero. Solucione esto intentando tomar una referencia en la estructura rxrpc_call y, si tiene éxito, pasando esa referencia al temporizador. Si el temporizador ya se estaba ejecutando, la referencia se descarta. La rutina de finalización del temporizador puede pasar la referencia al elemento de trabajo de la llamada cuando lo pone en cola. Si el temporizador o el elemento de trabajo ya estaban en cola o en ejecución, la referencia adicional se descarta."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/051360e51341cd17738d82c15a8226010c7cb7f6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4a7f62f91933c8ae5308f9127fd8ea48188b6bc3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/54df5a37f1d951ed27fd47bf9b15a42279582110",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5e3c11144e557a9dbf9a2f6abe444689ef9d8aae",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8cbf4ae7a2833767d63114573e5f9a45740cc975",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}