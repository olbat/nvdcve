{
  "id": "CVE-2024-41045",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-29T15:15:12.873",
  "lastModified": "2024-11-21T09:32:07.857",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Defer work in bpf_timer_cancel_and_free\n\nCurrently, the same case as previous patch (two timer callbacks trying\nto cancel each other) can be invoked through bpf_map_update_elem as\nwell, or more precisely, freeing map elements containing timers. Since\nthis relies on hrtimer_cancel as well, it is prone to the same deadlock\nsituation as the previous patch.\n\nIt would be sufficient to use hrtimer_try_to_cancel to fix this problem,\nas the timer cannot be enqueued after async_cancel_and_free. Once\nasync_cancel_and_free has been done, the timer must be reinitialized\nbefore it can be armed again. The callback running in parallel trying to\narm the timer will fail, and freeing bpf_hrtimer without waiting is\nsufficient (given kfree_rcu), and bpf_timer_cb will return\nHRTIMER_NORESTART, preventing the timer from being rearmed again.\n\nHowever, there exists a UAF scenario where the callback arms the timer\nbefore entering this function, such that if cancellation fails (due to\ntimer callback invoking this routine, or the target timer callback\nrunning concurrently). In such a case, if the timer expiration is\nsignificantly far in the future, the RCU grace period expiration\nhappening before it will free the bpf_hrtimer state and along with it\nthe struct hrtimer, that is enqueued.\n\nHence, it is clear cancellation needs to occur after\nasync_cancel_and_free, and yet it cannot be done inline due to deadlock\nissues. We thus modify bpf_timer_cancel_and_free to defer work to the\nglobal workqueue, adding a work_struct alongside rcu_head (both used at\n_different_ points of time, so can share space).\n\nUpdate existing code comments to reflect the new state of affairs."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Aplazar el trabajo en bpf_timer_cancel_and_free Actualmente, el mismo caso del parche anterior (dos devoluciones de llamada de temporizador que intentan cancelarse entre sí) también se puede invocar a través de bpf_map_update_elem, o más precisamente, liberando mapa elementos que contienen temporizadores. Dado que esto también depende de hrtimer_cancel, es propenso a la misma situación de punto muerto que el parche anterior. Sería suficiente usar hrtimer_try_to_cancel para solucionar este problema, ya que el temporizador no se puede poner en cola después de async_cancel_and_free. Una vez que se haya realizado async_cancel_and_free, el temporizador debe reinicializarse antes de poder armarse nuevamente. La devolución de llamada que se ejecuta en paralelo al intentar armar el temporizador fallará, y liberar bpf_hrtimer sin esperar es suficiente (dado kfree_rcu), y bpf_timer_cb devolverá HRTIMER_NORESTART, evitando que el temporizador se rearme nuevamente. Sin embargo, existe un escenario UAF en el que la devolución de llamada arma el temporizador antes de ingresar a esta función, de modo que si la cancelación falla (debido a que la devolución de llamada del temporizador invoca esta rutina o la devolución de llamada del temporizador de destino se ejecuta simultáneamente). En tal caso, si la expiración del temporizador está significativamente lejos en el futuro, la expiración del período de gracia de RCU que ocurra antes liberará el estado bpf_hrtimer y junto con él la estructura hrtimer, que está en cola. Por lo tanto, está claro que la cancelación debe ocurrir después de async_cancel_and_free y, sin embargo, no se puede realizar en línea debido a problemas de interbloqueo. Por lo tanto, modificamos bpf_timer_cancel_and_free para diferir el trabajo a la cola de trabajo global, agregando un work_struct junto con rcu_head (ambos usados en _diferentes_ puntos de tiempo, por lo que pueden compartir espacio). Actualice los comentarios del código existente para reflejar la nueva situación."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/7aa5a19279c3639ae8b758b63f05d0c616a39fa1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7aa5a19279c3639ae8b758b63f05d0c616a39fa1",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}