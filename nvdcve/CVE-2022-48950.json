{
  "cve": {
    "data_type": "CVE",
    "data_format": "MITRE",
    "data_version": "4.0",
    "CVE_data_meta": {
      "ID": "CVE-2022-48950",
      "ASSIGNER": "cve@kernel.org"
    },
    "problemtype": {
      "problemtype_data": [
        {
          "description": [

          ]
        }
      ]
    },
    "references": {
      "reference_data": [
        {
          "url": "https://git.kernel.org/stable/c/8bffa95ac19ff27c8261904f89d36c7fcf215d59",
          "name": "https://git.kernel.org/stable/c/8bffa95ac19ff27c8261904f89d36c7fcf215d59",
          "refsource": "",
          "tags": [

          ]
        },
        {
          "url": "https://git.kernel.org/stable/c/78e1317a174edbfd1182599bf76c092a2877672c",
          "name": "https://git.kernel.org/stable/c/78e1317a174edbfd1182599bf76c092a2877672c",
          "refsource": "",
          "tags": [

          ]
        },
        {
          "url": "https://git.kernel.org/stable/c/517e6a301f34613bff24a8e35b5455884f2d83d8",
          "name": "https://git.kernel.org/stable/c/517e6a301f34613bff24a8e35b5455884f2d83d8",
          "refsource": "",
          "tags": [

          ]
        }
      ]
    },
    "description": {
      "description_data": [
        {
          "lang": "en",
          "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix perf_pending_task() UaF\n\nPer syzbot it is possible for perf_pending_task() to run after the\nevent is free()'d. There are two related but distinct cases:\n\n - the task_work was already queued before destroying the event;\n - destroying the event itself queues the task_work.\n\nThe first cannot be solved using task_work_cancel() since\nperf_release() itself might be called from a task_work (____fput),\nwhich means the current->task_works list is already empty and\ntask_work_cancel() won't be able to find the perf_pending_task()\nentry.\n\nThe simplest alternative is extending the perf_event lifetime to cover\nthe task_work.\n\nThe second is just silly, queueing a task_work while you know the\nevent is going away makes no sense and is easily avoided by\nre-arranging how the event is marked STATE_DEAD and ensuring it goes\nthrough STATE_OFF on the way down."
        }
      ]
    }
  },
  "configurations": {
    "CVE_data_version": "4.0",
    "nodes": [

    ]
  },
  "impact": {
  },
  "publishedDate": "2024-10-21T20:15Z",
  "lastModifiedDate": "2024-10-23T15:13Z"
}