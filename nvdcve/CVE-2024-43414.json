{
  "id": "CVE-2024-43414",
  "sourceIdentifier": "security-advisories@github.com",
  "published": "2024-08-27T18:15:15.083",
  "lastModified": "2024-09-12T21:33:40.887",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "Apollo Federation is an architecture for declaratively composing APIs into a unified graph. Each team can own their slice of the graph independently, empowering them to deliver autonomously and incrementally. Instances of @apollo/query-planner >=2.0.0 and <2.8.5 are impacted by a denial-of-service vulnerability. @apollo/gateway versions >=2.0.0 and < 2.8.5 and Apollo Router <1.52.1 are also impacted through their use of @apollo/query-panner. If @apollo/query-planner is asked to plan a sufficiently complex query, it may loop infinitely and never complete. This results in unbounded memory consumption and either a crash or out-of-memory (OOM) termination. This issue can be triggered if you have at least one non-@key field that can be resolved by multiple subgraphs. To identify these shared fields, the schema for each subgraph must be reviewed. The mechanism to identify shared fields varies based on the version of Federation your subgraphs are using. You can check if your subgraphs are using Federation 1 or Federation 2 by reviewing their schemas. Federation 2 subgraph schemas will contain a @link directive referencing the version of Federation being used while Federation 1 subgraphs will not. For example, in a Federation 2 subgraph, you will find a line like @link(url: \"https://specs.apollo.dev/federation/v2.0\"). If a similar @link directive is not present in your subgraph schema, it is using Federation 1. Note that a supergraph can contain a mix of Federation 1 and Federation 2 subgraphs. This issue results from the Apollo query planner attempting to use a Number exceeding Javascript’s Number.MAX_VALUE in some cases. In Javascript, Number.MAX_VALUE is (2^1024 - 2^971). When the query planner receives an inbound graphql request, it breaks the query into pieces and for each piece, generates a list of potential execution steps to solve the piece. These candidates represent the steps that the query planner will take to satisfy the pieces of the larger query. As part of normal operations, the query planner requires and calculates the number of possible query plans for the total query. That is, it needs the product of the number of query plan candidates for each piece of the query. Under normal circumstances, after generating all query plan candidates and calculating the number of all permutations, the query planner moves on to stack rank candidates and prune less-than-optimal options. In particularly complex queries, especially those where fields can be solved through multiple subgraphs, this can cause the number of all query plan permutations to balloon. In worst-case scenarios, this can end up being a number larger than Number.MAX_VALUE. In Javascript, if Number.MAX_VALUE is exceeded, Javascript represents the value as “infinity”. If the count of candidates is evaluated as infinity, the component of the query planner responsible for pruning less-than-optimal query plans does not actually prune candidates, causing the query planner to evaluate many orders of magnitude more query plan candidates than necessary. This issue has been addressed in @apollo/query-planner v2.8.5, @apollo/gateway v2.8.5, and Apollo Router v1.52.1. Users are advised to upgrade. This issue can be avoided by ensuring there are no fields resolvable from multiple subgraphs. If all subgraphs are using Federation 2, you can confirm that you are not impacted by ensuring that none of your subgraph schemas use the @shareable directive. If you are using Federation 1 subgraphs, you will need to validate that there are no fields resolvable by multiple subgraphs."
    },
    {
      "lang": "es",
      "value": "Apollo Federation es una arquitectura para componer API de forma declarativa en un gráfico unificado. Cada equipo puede ser dueño de su porción del gráfico de forma independiente, lo que les permite realizar entregas de forma autónoma e incremental. Las instancias de @apollo/query-planner &gt;=2.0.0 y &lt;2.8.5 se ven afectadas por una vulnerabilidad de denegación de servicio. Las versiones de @apollo/gateway &gt;=2.0.0 y &lt;2.8.5 y Apollo Router &lt;1.52.1 también se ven afectadas por el uso de @apollo/query-panner. Si se le pide a @apollo/query-planner que planifique una consulta suficientemente compleja, es posible que se repita infinitamente y nunca se complete. Esto da como resultado un consumo de memoria ilimitado y una falla o terminación por falta de memoria (OOM). Este problema puede desencadenarse si tiene al menos un campo que no sea @key y que pueda resolverse mediante varios subgrafos. Para identificar estos campos compartidos, se debe revisar el esquema de cada subgrafo. El mecanismo para identificar campos compartidos varía según la versión de Federación que estén utilizando sus subgrafos. Puede comprobar si sus subgrafos utilizan la Federación 1 o la Federación 2 revisando sus esquemas. Los esquemas de subgrafos de Federación 2 contendrán una directiva @link que hace referencia a la versión de Federación que se utiliza, mientras que los subgrafos de Federación 1 no. Por ejemplo, en un subgrafo de Federación 2, encontrará una línea como @link(url: \"https://specs.apollo.dev/federation/v2.0\"). Si una directiva @link similar no está presente en su esquema de subgrafo, está utilizando la Federación 1. Tenga en cuenta que un supergrafo puede contener una combinación de subgrafos de Federación 1 y Federación 2. Este problema se debe a que el planificador de consultas de Apollo intenta utilizar un número que excede el número de Javascript.MAX_VALUE en algunos casos. En Javascript, Number.MAX_VALUE es (2^1024 - 2^971). Cuando el planificador de consultas recibe una solicitud Graphql entrante, divide la consulta en partes y, para cada parte, genera una lista de posibles pasos de ejecución para resolver la parte. Estos candidatos representan los pasos que seguirá el planificador de consultas para satisfacer las partes de la consulta más grande. Como parte de las operaciones normales, el planificador de consultas requiere y calcula la cantidad de planes de consulta posibles para la consulta total. Es decir, necesita el producto del número de candidatos al plan de consulta para cada parte de la consulta. En circunstancias normales, después de generar todos los candidatos al plan de consulta y calcular el número de todas las permutaciones, el planificador de consultas pasa a clasificar los candidatos y eliminar las opciones menos óptimas. En consultas particularmente complejas, especialmente aquellas donde los campos se pueden resolver a través de múltiples subgrafos, esto puede hacer que el número de todas las permutaciones del plan de consulta aumente. En el peor de los casos, esto puede terminar siendo un número mayor que Number.MAX_VALUE. En Javascript, si se excede Number.MAX_VALUE, Javascript representa el valor como \"infinito\". Si el recuento de candidatos se evalúa como infinito, el componente del planificador de consultas responsable de eliminar los planes de consultas que no son óptimos en realidad no elimina los candidatos, lo que hace que el planificador de consultas evalúe muchos órdenes de magnitud más candidatos a planes de consultas de los necesarios. Este problema se solucionó en @apollo/query-planner v2.8.5, @apollo/gateway v2.8.5 y Apollo Router v1.52.1. Se recomienda a los usuarios que actualicen. Este problema se puede evitar asegurándose de que no haya campos que se puedan resolver en varios subgrafos. Si todos los subgrafos utilizan la Federación 2, puede confirmar que no se verá afectado asegurándose de que ninguno de sus esquemas de subgrafos utilice la directiva @shareable. --- TRUNCADO ----"
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "security-advisories@github.com",
        "type": "Secondary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 7.5,
          "baseSeverity": "HIGH",
          "attackVector": "NETWORK",
          "attackComplexity": "LOW",
          "privilegesRequired": "NONE",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 3.9,
        "impactScore": 3.6
      },
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 7.5,
          "baseSeverity": "HIGH",
          "attackVector": "NETWORK",
          "attackComplexity": "LOW",
          "privilegesRequired": "NONE",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 3.9,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "security-advisories@github.com",
      "type": "Secondary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-674"
        }
      ]
    },
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-674"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:a:apollographql:apollo-router:*:*:*:*:*:rust:*:*",
              "versionEndExcluding": "1.52.1",
              "matchCriteriaId": "DC2E3CE8-4AA1-4201-9D25-747129D12CF6"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:a:apollographql:apollo_gateway:*:*:*:*:*:node.js:*:*",
              "versionStartIncluding": "2.0.0",
              "versionEndExcluding": "2.8.5",
              "matchCriteriaId": "34C12E9C-CB82-4258-BE8D-A33ACCB4DF16"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:a:apollographql:apollo_helms-charts_router:*:*:*:*:*:*:*:*",
              "versionEndExcluding": "1.52.1",
              "matchCriteriaId": "5E734618-8E22-4FE6-B19D-FBE43CE5751F"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:a:apollographql:apollo_query-planner:*:*:*:*:*:node.js:*:*",
              "versionStartIncluding": "2.0.0",
              "versionEndExcluding": "2.8.5",
              "matchCriteriaId": "A0231E1E-F9F9-4C81-9161-16443D79280A"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:a:apollographql:apollo_router:*:*:*:*:*:*:*:*",
              "versionEndExcluding": "1.52.1",
              "matchCriteriaId": "78F8E1F6-79E4-4B0B-A03B-EAC1D8898187"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://github.com/apollographql/federation/security/advisories/GHSA-fmj9-77q8-g6c4",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://www.apollographql.com/docs/federation/query-plans",
      "source": "security-advisories@github.com",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://www.apollographql.com/docs/router/configuration/persisted-queries",
      "source": "security-advisories@github.com",
      "tags": [
        "Technical Description"
      ]
    }
  ]
}