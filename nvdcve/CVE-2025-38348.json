{
  "id": "CVE-2025-38348",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-10T09:15:29.840",
  "lastModified": "2025-07-10T13:17:30.017",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: p54: prevent buffer-overflow in p54_rx_eeprom_readback()\n\nRobert Morris reported:\n\n|If a malicious USB device pretends to be an Intersil p54 wifi\n|interface and generates an eeprom_readback message with a large\n|eeprom->v1.len, p54_rx_eeprom_readback() will copy data from the\n|message beyond the end of priv->eeprom.\n|\n|static void p54_rx_eeprom_readback(struct p54_common *priv,\n|                                   struct sk_buff *skb)\n|{\n|        struct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n|        struct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr->data;\n|\n|        if (priv->fw_var >= 0x509) {\n|                memcpy(priv->eeprom, eeprom->v2.data,\n|                       le16_to_cpu(eeprom->v2.len));\n|        } else {\n|                memcpy(priv->eeprom, eeprom->v1.data,\n|                       le16_to_cpu(eeprom->v1.len));\n|        }\n| [...]\n\nThe eeprom->v{1,2}.len is set by the driver in p54_download_eeprom().\nThe device is supposed to provide the same length back to the driver.\nBut yes, it's possible (like shown in the report) to alter the value\nto something that causes a crash/panic due to overrun.\n\nThis patch addresses the issue by adding the size to the common device\ncontext, so p54_rx_eeprom_readback no longer relies on possibly tampered\nvalues... That said, it also checks if the \"firmware\" altered the value\nand no longer copies them.\n\nThe one, small saving grace is: Before the driver tries to read the eeprom,\nit needs to upload >a< firmware. the vendor firmware has a proprietary\nlicense and as a reason, it is not present on most distributions by\ndefault."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: p54: evitar desbordamiento de búfer en p54_rx_eeprom_readback() Robert Morris informó: |Si un dispositivo USB malicioso se hace pasar por una interfaz wifi p54 de Intersil y genera un mensaje eeprom_readback con un eeprom-&gt;v1.len largo, p54_rx_eeprom_readback() copiará los datos del mensaje más allá del final de priv-&gt;eeprom. | |static void p54_rx_eeprom_readback(struct p54_common *priv, | struct sk_buff *skb) |{ | struct p54_hdr *hdr = (struct p54_hdr *) skb-&gt;data; | struct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr-&gt;data; | | if (priv-&gt;fw_var &gt;= 0x509) { | memcpy(priv-&gt;eeprom, eeprom-&gt;v2.data, | le16_to_cpu(eeprom-&gt;v2.len)); | } else { | memcpy(priv-&gt;eeprom, eeprom-&gt;v1.data, | le16_to_cpu(eeprom-&gt;v1.len)); | } | [...] El controlador establece eeprom-&gt;v{1,2}.len en p54_download_eeprom(). Se supone que el dispositivo debe proporcionar la misma longitud al controlador. Sin embargo, es posible (como se muestra en el informe) modificar el valor para que provoque un bloqueo o pánico debido a un desbordamiento. Este parche soluciona el problema añadiendo el tamaño al contexto común del dispositivo, de modo que p54_rx_eeprom_readback ya no depende de valores posiblemente manipulados. Dicho esto, también comprueba si el firmware alteró el valor y ya no los copia. La única pequeña ventaja es que, antes de que el controlador intente leer la EEPROM, necesita cargar un firmware. El firmware del proveedor tiene una licencia propietaria y, por ello, no está presente en la mayoría de las distribuciones por defecto."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0e4dc150423b829c35cbcf399481ca11594fc036",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/12134f79e53eb56b0b0b7447fa0c512acf6a8422",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1f7f8168abe8cbe845ab8bb557228d44784a6b57",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/6d05390d20f110de37d051a3e063ef0a542d01fb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/714afb4c38edd19a057d519c1f9c5d164b43de94",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9701f842031b825e2fd5f22d064166f8f13f6e4d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/da1b9a55ff116cb040528ef664c70a4eec03ae99",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f39b2f8c1549a539846e083790fad396ef6cd802",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}