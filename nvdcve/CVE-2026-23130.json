{
  "id": "CVE-2026-23130",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-14T15:16:08.277",
  "lastModified": "2026-02-18T17:52:44.520",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix dead lock while flushing management frames\n\nCommit [1] converted the management transmission work item into a\nwiphy work. Since a wiphy work can only run under wiphy lock\nprotection, a race condition happens in below scenario:\n\n1. a management frame is queued for transmission.\n2. ath12k_mac_op_flush() gets called to flush pending frames associated\n   with the hardware (i.e, vif being NULL). Then in ath12k_mac_flush()\n   the process waits for the transmission done.\n3. Since wiphy lock has been taken by the flush process, the transmission\n   work item has no chance to run, hence the dead lock.\n\n>From user view, this dead lock results in below issue:\n\n wlp8s0: authenticate with xxxxxx (local address=xxxxxx)\n wlp8s0: send auth to xxxxxx (try 1/3)\n wlp8s0: authenticate with xxxxxx (local address=xxxxxx)\n wlp8s0: send auth to xxxxxx (try 1/3)\n wlp8s0: authenticated\n wlp8s0: associate with xxxxxx (try 1/3)\n wlp8s0: aborting association with xxxxxx by local choice (Reason: 3=DEAUTH_LEAVING)\n ath12k_pci 0000:08:00.0: failed to flush mgmt transmit queue, mgmt pkts pending 1\n\nThe dead lock can be avoided by invoking wiphy_work_flush() to proactively\nrun the queued work item. Note actually it is already present in\nath12k_mac_op_flush(), however it does not protect the case where vif\nbeing NULL. Hence move it ahead to cover this case as well.\n\nTested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.1.c5-00302-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1.115823.3"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad:\n\nwifi: ath12k: solucionar interbloqueo al vaciar tramas de gestión\n\nEl commit [1] convirtió el elemento de trabajo de transmisión de gestión en un trabajo wiphy. Dado que un trabajo wiphy solo puede ejecutarse bajo la protección del bloqueo wiphy, ocurre una condición de carrera en el siguiente escenario:\n\n1. una trama de gestión se pone en cola para transmisión.\n2. se llama a ath12k_mac_op_flush() para vaciar las tramas pendientes asociadas con el hardware (es decir, vif es NULL). Luego, en ath12k_mac_flush(), el proceso espera a que la transmisión finalice.\n3. Dado que el bloqueo wiphy ha sido tomado por el proceso de vaciado, el elemento de trabajo de transmisión no tiene oportunidad de ejecutarse, de ahí el interbloqueo.\n\nDesde la perspectiva del usuario, este interbloqueo resulta en el siguiente problema:\n\n wlp8s0: autenticar con xxxxxx (dirección local=xxxxxx)\n wlp8s0: enviar autenticación a xxxxxx (intento 1/3)\n wlp8s0: autenticar con xxxxxx (dirección local=xxxxxx)\n wlp8s0: enviar autenticación a xxxxxx (intento 1/3)\n wlp8s0: autenticado\n wlp8s0: asociar con xxxxxx (intento 1/3)\n wlp8s0: abortando asociación con xxxxxx por elección local (Razón: 3=DEAUTH_LEAVING)\n ath12k_pci 0000:08:00.0: falló al vaciar la cola de transmisión de gestión, paquetes de gestión pendientes 1\n\nEl interbloqueo puede evitarse invocando wiphy_work_flush() para ejecutar proactivamente el elemento de trabajo en cola. Nótese que en realidad ya está presente en ath12k_mac_op_flush(), sin embargo, no protege el caso en que vif es NULL. Por lo tanto, se mueve hacia adelante para cubrir también este caso.\n\nProbado en: WCN7850 hw2.0 PCI WLAN.HMT.1.1.c5-00302-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1.115823.3"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/06ac2aa13f701a0296e92f5f54ae24224d426b28",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f88e9fc30a261d63946ddc6cc6a33405e6aa27c3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}