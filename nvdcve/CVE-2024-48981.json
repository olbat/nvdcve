{
  "id": "CVE-2024-48981",
  "sourceIdentifier": "cve@mitre.org",
  "published": "2024-11-20T20:15:19.097",
  "lastModified": "2024-11-25T22:15:13.517",
  "vulnStatus": "Modified",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "An issue was discovered in MBed OS 6.16.0. During processing of HCI packets, the software dynamically determines the length of the packet header by looking up the identifying first byte and matching it against a table of possible lengths. The initial parsing function, hciTrSerialRxIncoming does not drop packets with invalid identifiers but also does not set a safe default for the length of unknown packets' headers, leading to a buffer overflow. This can be leveraged into an arbitrary write by an attacker. It is possible to overwrite the pointer to a not-yet-allocated buffer that is supposed to receive the contents of the packet body. One can then overwrite the state variable used by the function to determine which state of packet parsing is currently occurring. Because the buffer is allocated when the last byte of the header has been copied, the combination of having a bad header length variable that will never match the counter variable and being able to overwrite the state variable with the resulting buffer overflow can be used to advance the function to the next step while skipping the buffer allocation and resulting pointer write. The next 16 bytes from the packet body are then written wherever the corrupted data pointer is pointing."
    },
    {
      "lang": "es",
      "value": "Se descubrió un problema en MBed OS 6.16.0. Durante el procesamiento de paquetes HCI, el software determina dinámicamente la longitud del encabezado del paquete buscando el primer byte de identificación y comparándolo con una tabla de longitudes posibles. La función de análisis inicial, hciTrSerialRxIncoming, no descarta los paquetes con identificadores no válidos, pero tampoco establece un valor predeterminado seguro para la longitud de los encabezados de los paquetes desconocidos, lo que provoca un desbordamiento del búfer. Un atacante puede aprovechar esto para realizar una escritura arbitraria. Es posible sobrescribir el puntero a un búfer aún no asignado que se supone que debe recibir el contenido del cuerpo del paquete. Luego, se puede sobrescribir la variable de estado utilizada por la función para determinar qué estado del análisis del paquete se está produciendo actualmente. Debido a que el búfer se asigna cuando se ha copiado el último byte del encabezado, la combinación de tener una variable de longitud de encabezado incorrecta que nunca coincidirá con la variable de contador y poder sobrescribir la variable de estado con el desbordamiento de búfer resultante se puede utilizar para avanzar la función al siguiente paso mientras se omite la asignación de búfer y la escritura del puntero resultante. Los siguientes 16 bytes del cuerpo del paquete se escriben donde sea que apunte el puntero de datos dañado."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
          "baseScore": 7.5,
          "baseSeverity": "HIGH",
          "attackVector": "NETWORK",
          "attackComplexity": "LOW",
          "privilegesRequired": "NONE",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "HIGH",
          "availabilityImpact": "NONE"
        },
        "exploitabilityScore": 3.9,
        "impactScore": 3.6
      },
      {
        "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
        "type": "Secondary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
          "baseScore": 7.5,
          "baseSeverity": "HIGH",
          "attackVector": "NETWORK",
          "attackComplexity": "LOW",
          "privilegesRequired": "NONE",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "HIGH",
          "availabilityImpact": "NONE"
        },
        "exploitabilityScore": 3.9,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-120"
        }
      ]
    },
    {
      "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
      "type": "Secondary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-120"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:arm:mbed:6.16.0:*:*:*:*:*:*:*",
              "matchCriteriaId": "C9CE74E6-6FC6-4507-A9EE-F74B3E02FCB8"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://github.com/mbed-ce/mbed-os/blob/54e8693ef4ff7e025018094f290a1d5cf380941f/connectivity/FEATURE_BLE/source/cordio/stack_adaptation/hci_tr.c#L161",
      "source": "cve@mitre.org",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/mbed-ce/mbed-os/pull/374",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    }
  ]
}