{
  "id": "CVE-2024-48876",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-01-11T13:15:23.263",
  "lastModified": "2025-01-11T13:15:23.263",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nstackdepot: fix stack_depot_save_flags() in NMI context\n\nPer documentation, stack_depot_save_flags() was meant to be usable from\nNMI context if STACK_DEPOT_FLAG_CAN_ALLOC is unset.  However, it still\nwould try to take the pool_lock in an attempt to save a stack trace in the\ncurrent pool (if space is available).\n\nThis could result in deadlock if an NMI is handled while pool_lock is\nalready held.  To avoid deadlock, only try to take the lock in NMI context\nand give up if unsuccessful.\n\nThe documentation is fixed to clearly convey this."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: stackdepot: se corrige stack_depot_save_flags() en el contexto NMI Según la documentación, se suponía que stack_depot_save_flags() se podía usar desde el contexto NMI si STACK_DEPOT_FLAG_CAN_ALLOC no está configurado. Sin embargo, aún intentaría tomar el pool_lock en un intento de guardar un seguimiento de pila en el pool actual (si hay espacio disponible). Esto podría resultar en un bloqueo si se gestiona un NMI mientras pool_lock ya está retenido. Para evitar el bloqueo, solo intente tomar el bloqueo en el contexto NMI y abandone si no tiene éxito. La documentación se corrige para transmitir esto claramente."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/031e04bdc834cda3b054ef6b698503b2b97e8186",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9bfeeeff2c92b9dd261198b601b45bde4c529841",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}