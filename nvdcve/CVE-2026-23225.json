{
  "id": "CVE-2026-23225",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-18T16:22:32.260",
  "lastModified": "2026-02-18T17:51:53.510",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/mmcid: Don't assume CID is CPU owned on mode switch\n\nShinichiro reported a KASAN UAF, which is actually an out of bounds access\nin the MMCID management code.\n\n   CPU0\t\t\t\t\t\tCPU1\n   \t\t\t\t\t\tT1 runs in userspace\n   T0: fork(T4) -> Switch to per CPU CID mode\n         fixup() set MM_CID_TRANSIT on T1/CPU1\n   T4 exit()\n   T3 exit()\n   T2 exit()\n\t\t\t\t\t\tT1 exit() switch to per task mode\n\t\t\t\t\t\t ---> Out of bounds access.\n\nAs T1 has not scheduled after T0 set the TRANSIT bit, it exits with the\nTRANSIT bit set. sched_mm_cid_remove_user() clears the TRANSIT bit in\nthe task and drops the CID, but it does not touch the per CPU storage.\nThat's functionally correct because a CID is only owned by the CPU when\nthe ONCPU bit is set, which is mutually exclusive with the TRANSIT flag.\n\nNow sched_mm_cid_exit() assumes that the CID is CPU owned because the\nprior mode was per CPU. It invokes mm_drop_cid_on_cpu() which clears the\nnot set ONCPU bit and then invokes clear_bit() with an insanely large\nbit number because TRANSIT is set (bit 29).\n\nPrevent that by actually validating that the CID is CPU owned in\nmm_drop_cid_on_cpu()."
    },
    {
      "lang": "es",
      "value": "Se ha resuelto la siguiente vulnerabilidad en el kernel de Linux:\n\nsched/mmcid: No asumir que el CID es propiedad de la CPU en el cambio de modo\n\nShinichiro informó de un KASAN UAF, que en realidad es un acceso fuera de límites en el código de gestión de MMCID.\n\n   CPU0\t\t\t\t\t\tCPU1\n   \t\t\t\t\t\tT1 se ejecuta en espacio de usuario\n   T0: fork(T4) -&gt; Cambio a modo CID por CPU\n         fixup() establece MM_CID_TRANSIT en T1/CPU1\n   T4 sale()\n   T3 sale()\n   T2 sale()\n\t\t\t\t\t\tT1 sale() cambia a modo por tarea\n\t\t\t\t\t\t ---&gt; Acceso fuera de límites.\n\nComo T1 no se ha planificado después de que T0 estableciera el bit TRANSIT, sale con el bit TRANSIT establecido. sched_mm_cid_remove_user() borra el bit TRANSIT en la tarea y elimina el CID, pero no toca el almacenamiento por CPU. Eso es el funcionalmente correcto porque un CID solo es propiedad de la CPU cuando el bit ONCPU está establecido, lo cual es mutuamente excluyente con el indicador TRANSIT.\n\nAhora sched_mm_cid_exit() asume que el CID es propiedad de la CPU porque el modo anterior era por CPU. Invoca mm_drop_cid_on_cpu() que borra el bit ONCPU no establecido y luego invoca clear_bit() con un número de bit increíblemente grande porque TRANSIT está establecido (bit 29).\n\nEvitar eso validando realmente que el CID es propiedad de la CPU en mm_drop_cid_on_cpu()."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/81f29975631db8a78651b3140ecd0f88ffafc476",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}