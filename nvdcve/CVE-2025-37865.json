{
  "id": "CVE-2025-37865",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-05-09T07:16:07.530",
  "lastModified": "2025-05-12T17:32:32.760",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: mv88e6xxx: fix -ENOENT when deleting VLANs and MST is unsupported\n\nRussell King reports that on the ZII dev rev B, deleting a bridge VLAN\nfrom a user port fails with -ENOENT:\nhttps://lore.kernel.org/netdev/Z_lQXNP0s5-IiJzd@shell.armlinux.org.uk/\n\nThis comes from mv88e6xxx_port_vlan_leave() -> mv88e6xxx_mst_put(),\nwhich tries to find an MST entry in &chip->msts associated with the SID,\nbut fails and returns -ENOENT as such.\n\nBut we know that this chip does not support MST at all, so that is not\nsurprising. The question is why does the guard in mv88e6xxx_mst_put()\nnot exit early:\n\n\tif (!sid)\n\t\treturn 0;\n\nAnd the answer seems to be simple: the sid comes from vlan.sid which\nsupposedly was previously populated by mv88e6xxx_vtu_get().\nBut some chip->info->ops->vtu_getnext() implementations do not populate\nvlan.sid, for example see mv88e6185_g1_vtu_getnext(). In that case,\nlater in mv88e6xxx_port_vlan_leave() we are using a garbage sid which is\njust residual stack memory.\n\nTesting for sid == 0 covers all cases of a non-bridge VLAN or a bridge\nVLAN mapped to the default MSTI. For some chips, SID 0 is valid and\ninstalled by mv88e6xxx_stu_setup(). A chip which does not support the\nSTU would implicitly only support mapping all VLANs to the default MSTI,\nso although SID 0 is not valid, it would be sufficient, if we were to\nzero-initialize the vlan structure, to fix the bug, due to the\ncoincidence that a test for vlan.sid == 0 already exists and leads to\nthe same (correct) behavior.\n\nAnother option which would be sufficient would be to add a test for\nmv88e6xxx_has_stu() inside mv88e6xxx_mst_put(), symmetric to the one\nwhich already exists in mv88e6xxx_mst_get(). But that placement means\nthe caller will have to dereference vlan.sid, which means it will access\nuninitialized memory, which is not nice even if it ignores it later.\n\nSo we end up making both modifications, in order to not rely just on the\nsid == 0 coincidence, but also to avoid having uninitialized structure\nfields which might get temporarily accessed."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: dsa: mv88e6xxx: corrección de -ENOENT al eliminar VLAN y MST no es compatible Russell King informa que en ZII dev rev B, la eliminación de una VLAN de puente de un puerto de usuario falla con -ENOENT: https://lore.kernel.org/netdev/Z_lQXNP0s5-IiJzd@shell.armlinux.org.uk/ Esto viene de mv88e6xxx_port_vlan_leave() -&gt; mv88e6xxx_mst_put(), que intenta encontrar una entrada MST en &amp;chip-&gt;msts asociada con el SID, pero falla y devuelve -ENOENT como tal. Pero sabemos que este chip no admite MST en absoluto, por lo que no es sorprendente. La pregunta es por qué la protección en mv88e6xxx_mst_put() no sale antes: if (!sid) return 0; La respuesta parece sencilla: el SID proviene de vlan.sid, que supuestamente se rellenaba previamente con mv88e6xxx_vtu_get(). Sin embargo, algunas implementaciones de chip-&gt;info-&gt;ops-&gt;vtu_getnext() no rellenan vlan.sid; por ejemplo, véase mv88e6185_g1_vtu_getnext(). En ese caso, más adelante en mv88e6xxx_port_vlan_leave(), usamos un SID no válido, que es simplemente memoria de pila residual. La prueba de sid == 0 cubre todos los casos de una VLAN sin puente o una VLAN de puente asignada al MSTI predeterminado. Para algunos chips, el SID 0 es válido y se instala con mv88e6xxx_stu_setup(). Un chip que no admita la STU solo permitiría, implícitamente, la asignación de todas las VLAN al MSTI predeterminado. Por lo tanto, aunque el SID 0 no es válido, bastaría con inicializar a cero la estructura de la VLAN para corregir el error, debido a la coincidencia de que ya existe una prueba para vlan.sid == 0 que produce el mismo comportamiento (correcto). Otra opción suficiente sería añadir una prueba para mv88e6xxx_has_stu() dentro de mv88e6xxx_mst_put(), simétrica a la existente en mv88e6xxx_mst_get(). Sin embargo, esta ubicación implica que el emisor tendrá que desreferenciar vlan.sid, lo que implica acceder a memoria no inicializada, lo cual no es conveniente incluso si lo ignora posteriormente. Por lo tanto, realizamos ambas modificaciones para no depender solo de la coincidencia de sid == 0, sino también para evitar tener campos de estructura sin inicializar a los que se pueda acceder temporalmente."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/35cde75c08a1fa1a5ac0467afe2709caceeef002",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9da4acbd60664271d34a627f7f63cd5bad8eba74",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9ee6d3a368ed34f2457863da3085c676e9e37a3d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/afae9087301471970254a9180e5a26d3d8e8af09",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ea08dfc35f83cfc73493c52f63ae4f2e29edfe8d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}