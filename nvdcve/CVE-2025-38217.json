{
  "id": "CVE-2025-38217",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-04T14:15:30.227",
  "lastModified": "2025-07-08T16:18:53.607",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [

  ],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (ftsteutates) Fix TOCTOU race in fts_read()\n\nIn the fts_read() function, when handling hwmon_pwm_auto_channels_temp,\nthe code accesses the shared variable data->fan_source[channel] twice\nwithout holding any locks. It is first checked against\nFTS_FAN_SOURCE_INVALID, and if the check passes, it is read again\nwhen used as an argument to the BIT() macro.\n\nThis creates a Time-of-Check to Time-of-Use (TOCTOU) race condition.\nAnother thread executing fts_update_device() can modify the value of\ndata->fan_source[channel] between the check and its use. If the value\nis changed to FTS_FAN_SOURCE_INVALID (0xff) during this window, the\nBIT() macro will be called with a large shift value (BIT(255)).\nA bit shift by a value greater than or equal to the type width is\nundefined behavior and can lead to a crash or incorrect values being\nreturned to userspace.\n\nFix this by reading data->fan_source[channel] into a local variable\nonce, eliminating the race condition. Additionally, add a bounds check\nto ensure the value is less than BITS_PER_LONG before passing it to\nthe BIT() macro, making the code more robust against undefined behavior.\n\nThis possible bug was found by an experimental static analysis tool\ndeveloped by our team."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: hwmon: (ftsteutates) Corregir la ejecución TOCTOU en fts_read() En la función fts_read(), al manejar hwmon_pwm_auto_channels_temp, el código accede a la variable compartida data-&gt;fan_source[channel] dos veces sin mantener ningún bloqueo. Primero se compara con FTS_FAN_SOURCE_INVALID y, si la comprobación es correcta, se vuelve a leer cuando se usa como argumento de la macro BIT(). Esto crea una condición de ejecución de tiempo de comprobación a tiempo de uso (TOCTOU). Otro hilo que ejecute fts_update_device() puede modificar el valor de data-&gt;fan_source[channel] entre la comprobación y su uso. Si el valor se cambia a FTS_FAN_SOURCE_INVALID (0xff) durante esta ventana, se llamará a la macro BIT() con un valor de desplazamiento grande (BIT(255)). Un desplazamiento de bits por un valor mayor o igual al ancho del tipo es un comportamiento indefinido que puede provocar un fallo o la devolución de valores incorrectos al espacio de usuario. Para solucionarlo, lea data-&gt;fan_source[channel] en una variable local una vez, eliminando así la condición de ejecución. Además, añada una comprobación de los límites para garantizar que el valor sea menor que BITS_PER_LONG antes de pasarlo a la macro BIT(), lo que aumenta la robustez del código frente a comportamientos indefinidos. Este posible error fue detectado por una herramienta de análisis estático experimental desarrollada por nuestro equipo."
    }
  ],
  "metrics": {
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/14c9ede9ca4cd078ad76a6ab9617b81074eb58bf",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4d646f627d3b7ed1cacca66e598af8bcd632d465",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/83e2ba8971ccd8fc08319fc7593288f070d80a76",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d95d87841d2a575bed3691884e8fedef57d7710d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}