{
  "id": "CVE-2022-48827",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-16T12:15:06.420",
  "lastModified": "2024-11-21T07:34:09.767",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix the behavior of READ near OFFSET_MAX\n\nDan Aloni reports:\n> Due to commit 8cfb9015280d (\"NFS: Always provide aligned buffers to\n> the RPC read layers\") on the client, a read of 0xfff is aligned up\n> to server rsize of 0x1000.\n>\n> As a result, in a test where the server has a file of size\n> 0x7fffffffffffffff, and the client tries to read from the offset\n> 0x7ffffffffffff000, the read causes loff_t overflow in the server\n> and it returns an NFS code of EINVAL to the client. The client as\n> a result indefinitely retries the request.\n\nThe Linux NFS client does not handle NFS?ERR_INVAL, even though all\nNFS specifications permit servers to return that status code for a\nREAD.\n\nInstead of NFS?ERR_INVAL, have out-of-range READ requests succeed\nand return a short result. Set the EOF flag in the result to prevent\nthe client from retrying the READ request. This behavior appears to\nbe consistent with Solaris NFS servers.\n\nNote that NFSv3 and NFSv4 use u64 offset values on the wire. These\nmust be converted to loff_t internally before use -- an implicit\ntype cast is not adequate for this purpose. Otherwise VFS checks\nagainst sb->s_maxbytes do not work properly."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: NFSD: corrige el comportamiento de READ cerca de OFFSET_MAX Dan Aloni informa: &gt; Debido a El commit 8cfb9015280d (\"NFS: siempre proporcione buffers alineados a &gt; las capas de lectura RPC\") en el cliente, una lectura de 0xfff está alineada con el tamaño del servidor de 0x1000. &gt; &gt; Como resultado, en una prueba donde el servidor tiene un archivo de tamaño &gt; 0x7ffffffffffffffff, y el cliente intenta leer desde el desplazamiento &gt; 0x7ffffffffffffff000, la lectura causa que loff_t se desborde en el servidor &gt; y devuelve un código NFS de EINVAL a el cliente. Como resultado, el cliente reintenta indefinidamente la solicitud. El cliente NFS de Linux no maneja NFS?ERR_INVAL, aunque todas las especificaciones de NFS permiten a los servidores devolver ese código de estado para una READ. En lugar de NFS?ERR_INVAL, haga que las solicitudes READ fuera de rango se realicen correctamente y devuelvan un resultado breve. Establezca el indicador EOF en el resultado para evitar que el cliente vuelva a intentar la solicitud READ. Este comportamiento parece ser coherente con los servidores Solaris NFS. Tenga en cuenta que NFSv3 y NFSv4 utilizan valores de compensación u64 en el cable. Estos deben convertirse a loff_t internamente antes de su uso; una conversión de tipo implícita no es adecuada para este propósito. De lo contrario, las comprobaciones de VFS con sb-&gt;s_maxbytes no funcionan correctamente."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0cb4d23ae08c48f6bf3c29a8e5c4a74b8388b960",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1726a39b0879acfb490b22dca643f26f4f907da9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/44502aca8e02ab32d6b0eb52e006a5ec9402719b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c6eff5c4277146a78b4fb8c9b668dd64542c41b0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/0cb4d23ae08c48f6bf3c29a8e5c4a74b8388b960",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/1726a39b0879acfb490b22dca643f26f4f907da9",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/44502aca8e02ab32d6b0eb52e006a5ec9402719b",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/c6eff5c4277146a78b4fb8c9b668dd64542c41b0",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}