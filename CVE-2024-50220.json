{
  "id": "CVE-2024-50220",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-11-09T11:15:07.487",
  "lastModified": "2025-09-26T16:05:17.347",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nfork: do not invoke uffd on fork if error occurs\n\nPatch series \"fork: do not expose incomplete mm on fork\".\n\nDuring fork we may place the virtual memory address space into an\ninconsistent state before the fork operation is complete.\n\nIn addition, we may encounter an error during the fork operation that\nindicates that the virtual memory address space is invalidated.\n\nAs a result, we should not be exposing it in any way to external machinery\nthat might interact with the mm or VMAs, machinery that is not designed to\ndeal with incomplete state.\n\nWe specifically update the fork logic to defer khugepaged and ksm to the\nend of the operation and only to be invoked if no error arose, and\ndisallow uffd from observing fork events should an error have occurred.\n\n\nThis patch (of 2):\n\nCurrently on fork we expose the virtual address space of a process to\nuserland unconditionally if uffd is registered in VMAs, regardless of\nwhether an error arose in the fork.\n\nThis is performed in dup_userfaultfd_complete() which is invoked\nunconditionally, and performs two duties - invoking registered handlers\nfor the UFFD_EVENT_FORK event via dup_fctx(), and clearing down\nuserfaultfd_fork_ctx objects established in dup_userfaultfd().\n\nThis is problematic, because the virtual address space may not yet be\ncorrectly initialised if an error arose.\n\nThe change in commit d24062914837 (\"fork: use __mt_dup() to duplicate\nmaple tree in dup_mmap()\") makes this more pertinent as we may be in a\nstate where entries in the maple tree are not yet consistent.\n\nWe address this by, on fork error, ensuring that we roll back state that\nwe would otherwise expect to clean up through the event being handled by\nuserland and perform the memory freeing duty otherwise performed by\ndup_userfaultfd_complete().\n\nWe do this by implementing a new function, dup_userfaultfd_fail(), which\nperforms the same loop, only decrementing reference counts.\n\nNote that we perform mmgrab() on the parent and child mm's, however\nuserfaultfd_ctx_put() will mmdrop() this once the reference count drops to\nzero, so we will avoid memory leaks correctly here."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: fork: no invocar uffd en fork si ocurre un error Serie de parches \"fork: no exponer mm incompleto en fork\". Durante fork podemos colocar el espacio de direcciones de memoria virtual en un estado inconsistente antes de que se complete la operación de fork. Además, podemos encontrar un error durante la operación de fork que indique que el espacio de direcciones de memoria virtual está invalidado. Como resultado, no deberíamos exponerlo de ninguna manera a maquinaria externa que pueda interactuar con mm o VMAs, maquinaria que no está diseñada para lidiar con estado incompleto. Actualizamos específicamente la lógica de fork para diferir khugepaged y ksm hasta el final de la operación y solo para ser invocados si no surgió ningún error, y no permitimos que uffd observe eventos de fork si se ha producido un error. Este parche (de 2): Actualmente en fork exponemos el espacio de direcciones virtuales de un proceso al espacio de usuario incondicionalmente si uffd está registrado en VMAs, independientemente de si surgió un error en la bifurcación. Esto se realiza en dup_userfaultfd_complete(), que se invoca de manera incondicional y realiza dos tareas: invocar controladores registrados para el evento UFFD_EVENT_FORK a través de dup_fctx() y limpiar los objetos userfaultfd_fork_ctx establecidos en dup_userfaultfd(). Esto es problemático, porque el espacio de direcciones virtuales puede no estar inicializado correctamente si surge un error. El cambio en el commit d24062914837 (\"fork: use __mt_dup() to duplicate maple tree in dup_mmap()\") hace que esto sea más pertinente, ya que podemos estar en un estado en el que las entradas en el árbol de maple aún no sean consistentes. Abordamos esto, en caso de error de fork, asegurándonos de revertir el estado que de otra manera esperaríamos limpiar a través del evento que está siendo manejado por el espacio de usuario y realizar la tarea de liberación de memoria que de otra manera realizaría dup_userfaultfd_complete(). Para ello, implementamos una nueva función, dup_userfaultfd_fail(), que realiza el mismo bucle, pero disminuyendo el recuento de referencias. Tenga en cuenta que ejecutamos mmgrab() en los mm principales y secundarios, sin embargo, userfaultfd_ctx_put() ejecutará mmdrop() una vez que el recuento de referencias baje a cero, por lo que evitaremos fugas de memoria correctamente aquí."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 4.7,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "HIGH",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.0,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-367"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.8",
              "versionEndExcluding": "6.11.7",
              "matchCriteriaId": "40C0D9F3-9632-46FE-AA28-8CD73B52DEE7"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*",
              "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*",
              "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*",
              "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc4:*:*:*:*:*:*",
              "matchCriteriaId": "E0F717D8-3014-4F84-8086-0124B2111379"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc5:*:*:*:*:*:*",
              "matchCriteriaId": "24DBE6C7-2AAE-4818-AED2-E131F153D2FA"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/92b472945dbf8abc020e9259c0088026f7027dfc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/f64e67e5d3a45a4a04286c47afade4b518acd47b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://project-zero.issues.chromium.org/issues/373391951",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ]
}