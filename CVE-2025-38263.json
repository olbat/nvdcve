{
  "id": "CVE-2025-38263",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-09T11:15:28.690",
  "lastModified": "2025-07-17T17:15:39.260",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbcache: fix NULL pointer in cache_set_flush()\n\n1. LINE#1794 - LINE#1887 is some codes about function of\n   bch_cache_set_alloc().\n2. LINE#2078 - LINE#2142 is some codes about function of\n   register_cache_set().\n3. register_cache_set() will call bch_cache_set_alloc() in LINE#2098.\n\n 1794 struct cache_set *bch_cache_set_alloc(struct cache_sb *sb)\n 1795 {\n ...\n 1860         if (!(c->devices = kcalloc(c->nr_uuids, sizeof(void *), GFP_KERNEL)) ||\n 1861             mempool_init_slab_pool(&c->search, 32, bch_search_cache) ||\n 1862             mempool_init_kmalloc_pool(&c->bio_meta, 2,\n 1863                                 sizeof(struct bbio) + sizeof(struct bio_vec) *\n 1864                                 bucket_pages(c)) ||\n 1865             mempool_init_kmalloc_pool(&c->fill_iter, 1, iter_size) ||\n 1866             bioset_init(&c->bio_split, 4, offsetof(struct bbio, bio),\n 1867                         BIOSET_NEED_BVECS|BIOSET_NEED_RESCUER) ||\n 1868             !(c->uuids = alloc_bucket_pages(GFP_KERNEL, c)) ||\n 1869             !(c->moving_gc_wq = alloc_workqueue(\"bcache_gc\",\n 1870                                                 WQ_MEM_RECLAIM, 0)) ||\n 1871             bch_journal_alloc(c) ||\n 1872             bch_btree_cache_alloc(c) ||\n 1873             bch_open_buckets_alloc(c) ||\n 1874             bch_bset_sort_state_init(&c->sort, ilog2(c->btree_pages)))\n 1875                 goto err;\n                      ^^^^^^^^\n 1876\n ...\n 1883         return c;\n 1884 err:\n 1885         bch_cache_set_unregister(c);\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n 1886         return NULL;\n 1887 }\n ...\n 2078 static const char *register_cache_set(struct cache *ca)\n 2079 {\n ...\n 2098         c = bch_cache_set_alloc(&ca->sb);\n 2099         if (!c)\n 2100                 return err;\n                      ^^^^^^^^^^\n ...\n 2128         ca->set = c;\n 2129         ca->set->cache[ca->sb.nr_this_dev] = ca;\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n 2138         return NULL;\n 2139 err:\n 2140         bch_cache_set_unregister(c);\n 2141         return err;\n 2142 }\n\n(1) If LINE#1860 - LINE#1874 is true, then do 'goto err'(LINE#1875) and\n    call bch_cache_set_unregister()(LINE#1885).\n(2) As (1) return NULL(LINE#1886), LINE#2098 - LINE#2100 would return.\n(3) As (2) has returned, LINE#2128 - LINE#2129 would do *not* give the\n    value to c->cache[], it means that c->cache[] is NULL.\n\nLINE#1624 - LINE#1665 is some codes about function of cache_set_flush().\nAs (1), in LINE#1885 call\nbch_cache_set_unregister()\n---> bch_cache_set_stop()\n     ---> closure_queue()\n          -.-> cache_set_flush() (as below LINE#1624)\n\n 1624 static void cache_set_flush(struct closure *cl)\n 1625 {\n ...\n 1654         for_each_cache(ca, c, i)\n 1655                 if (ca->alloc_thread)\n                          ^^\n 1656                         kthread_stop(ca->alloc_thread);\n ...\n 1665 }\n\n(4) In LINE#1655 ca is NULL(see (3)) in cache_set_flush() then the\n    kernel crash occurred as below:\n[  846.712887] bcache: register_cache() error drbd6: cannot allocate memory\n[  846.713242] bcache: register_bcache() error : failed to register device\n[  846.713336] bcache: cache_set_free() Cache set 2f84bdc1-498a-4f2f-98a7-01946bf54287 unregistered\n[  846.713768] BUG: unable to handle kernel NULL pointer dereference at 00000000000009f8\n[  846.714790] PGD 0 P4D 0\n[  846.715129] Oops: 0000 [#1] SMP PTI\n[  846.715472] CPU: 19 PID: 5057 Comm: kworker/19:16 Kdump: loaded Tainted: G           OE    --------- -  - 4.18.0-147.5.1.el8_1.5es.3.x86_64 #1\n[  846.716082] Hardware name: ESPAN GI-25212/X11DPL-i, BIOS 2.1 06/15/2018\n[  846.716451] Workqueue: events cache_set_flush [bcache]\n[  846.716808] RIP: 0010:cache_set_flush+0xc9/0x1b0 [bcache]\n[  846.717155] Code: 00 4c 89 a5 b0 03 00 00 48 8b 85 68 f6 ff ff a8 08 0f 84 88 00 00 00 31 db 66 83 bd 3c f7 ff ff 00 48 8b 85 48 ff ff ff 74 28 <48> 8b b8 f8 09 00 0\n---truncated---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bcache: arregla el puntero NULL en cache_set_flush() 1. LÍNEA#1794 - LÍNEA#1887 son algunos códigos sobre la función de bch_cache_set_alloc(). 2. LÍNEA#2078 - LÍNEA#2142 son algunos códigos sobre la función de register_cache_set(). 3. register_cache_set() llamará a bch_cache_set_alloc() en la LÍNEA#2098. 1794 estructura caché_set *bch_cache_set_alloc(estructura caché_sb *sb) 1795 { ... 1860 si (!(c-&gt;dispositivos = kcalloc(c-&gt;nr_uuids, tamaño de(void *), GFP_KERNEL)) || 1861 mempool_init_slab_pool(&amp;c-&gt;búsqueda, 32, bch_búsqueda_cache) || 1862 mempool_init_kmalloc_pool(&amp;c-&gt;bio_meta, 2, 1863 tamaño de(estructura bbio) + tamaño de(estructura bio_vec) * 1864 páginas_de_depósito(c)) || 1865 mempool_init_kmalloc_pool(&amp;c-&gt;rellenar_iter, 1, tamaño_de_iter) || 1866 bioset_init(&amp;c-&gt;bio_split, 4, offsetof(struct bbio, bio), 1867 BIOSET_NEED_BVECS|BIOSET_NEED_RESCUER) || 1868 !(c-&gt;uuids = alloc_bucket_pages(GFP_KERNEL, c)) || 1869 !(c-&gt;moving_gc_wq = alloc_workqueue(\"bcache_gc\", 1870 WQ_MEM_RECLAIM, 0)) || 1871 bch_journal_alloc(c) || 1872 bch_btree_cache_alloc(c) || 1873 bch_open_buckets_alloc(c) || 1874 bch_bset_sort_state_init(&amp;c-&gt;sort, ilog2(c-&gt;btree_pages))) 1875 goto err; ^^^^^^^^ 1876 ... 1883 devolver c; 1884 err: 1885 bch_cache_set_unregister(c); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 1886 devolver NULL; 1887 } ... 2078 static const char *register_cache_set(struct cache *ca) 2079 { ... 2098 c = bch_cache_set_alloc(&amp;ca-&gt;sb); 2099 if (!c) 2100 devolver err; ^^^^^^^^^^ ... 2128 ca-&gt;set = c; 2129 ca-&gt;set-&gt;cache[ca-&gt;sb.nr_this_dev] = ca; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^... 2138 return NULL; 2139 err: 2140 bch_cache_set_unregister(c); 2141 return err; 2142 } (1) Si LÍNEA#1860 - LÍNEA#1874 es verdadero, entonces haga 'goto err'(LÍNEA#1875) y llame a bch_cache_set_unregister()(LÍNEA#1885). (2) Como (1) devuelve NULL(LÍNEA#1886), LÍNEA#2098 - LÍNEA#2100 retornaría. (3) Como (2) ha retornado, la LÍNEA n.º 2128 - LÍNEA n.º 2129 *no* daría el valor a c-&gt;cache[], lo que significa que c-&gt;cache[] es NULL. LA LÍNEA n.º 1624 - LÍNEA n.º 1665 son algunos códigos sobre la función de cache_set_flush(). Como (1), en la LÍNEA n.º 1885 llame a bch_cache_set_unregister() ---&gt; bch_cache_set_stop() ---&gt; closure_queue() -.-&gt; cache_set_flush() (como se muestra a continuación en la LÍNEA n.º 1624) 1624 static void cache_set_flush(struct closure *cl) 1625 { ... 1654 for_each_cache(ca, c, i) 1655 if (ca-&gt;alloc_thread) ^^ 1656 kthread_stop(ca-&gt;alloc_thread); ... 1665 } (4) En la LÍNEA n.º 1655 ca es NULL (ver (3)) en cache_set_flush(), entonces ocurrió el fallo del núcleo como se muestra a continuación: [846.712887] bcache: error de register_cache() drbd6: no se puede asignar memoria [846.713242] bcache: error de register_bcache(): no se pudo registrar el dispositivo [846.713336] bcache: cache_set_free() Conjunto de caché 2f84bdc1-498a-4f2f-98a7-01946bf54287 no registrado [846.713768] ERROR: no se puede manejar la desreferencia del puntero NULL del núcleo en 00000000000009f8 [846.714790] PGD 0 P4D 0 [ 846.715129] Oops: 0000 [#1] SMP PTI [ 846.715472] CPU: 19 PID: 5057 Comm: kworker/19:16 Kdump: cargado Contaminado: G OE --------- - - 4.18.0-147.5.1.el8_1.5es.3.x86_64 #1 [ 846.716082] Nombre del hardware: ESPAN GI-25212/X11DPL-i, BIOS 2.1 15/06/2018 [ 846.716451] Cola de trabajo: eventos cache_set_flush [bcache] [ 846.716808] RIP: 0010:cache_set_flush+0xc9/0x1b0 [bcache] [ 846.717155] Código: 00 4c 89 a5 b0 03 00 00 48 8b 85 68 f6 ff ff a8 08 0f 84 88 00 00 00 31 db 66 83 bd 3c f7 ff ff 00 48 8b 85 48 ff ff ff 74 28 &lt;48&gt; 8b b8 f8 09 00 0 ---truncado---"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1e46ed947ec658f89f1a910d880cd05e42d3763e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1f25f2d3fa29325320c19a30abf787e0bd5fc91b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3f9e128186c99a117e304f1dce6d0b9e50c63cd8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/553f560e0a74a7008ad9dba05c3fd05da296befb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/667c3f52373ff5354cb3543e27237eb7df7b2333",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c4f5e7e417034b05f5d2f5fa9a872db897da69bd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d54681938b777488e5dfb781b566d16adad991de",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}