{
  "id": "CVE-2025-21709",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-27T02:15:14.560",
  "lastModified": "2025-10-23T17:45:03.190",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nkernel: be more careful about dup_mmap() failures and uprobe registering\n\nIf a memory allocation fails during dup_mmap(), the maple tree can be left\nin an unsafe state for other iterators besides the exit path.  All the\nlocks are dropped before the exit_mmap() call (in mm/mmap.c), but the\nincomplete mm_struct can be reached through (at least) the rmap finding\nthe vmas which have a pointer back to the mm_struct.\n\nUp to this point, there have been no issues with being able to find an\nmm_struct that was only partially initialised.  Syzbot was able to make\nthe incomplete mm_struct fail with recent forking changes, so it has been\nproven unsafe to use the mm_struct that hasn't been initialised, as\nreferenced in the link below.\n\nAlthough 8ac662f5da19f (\"fork: avoid inappropriate uprobe access to\ninvalid mm\") fixed the uprobe access, it does not completely remove the\nrace.\n\nThis patch sets the MMF_OOM_SKIP to avoid the iteration of the vmas on the\noom side (even though this is extremely unlikely to be selected as an oom\nvictim in the race window), and sets MMF_UNSTABLE to avoid other potential\nusers from using a partially initialised mm_struct.\n\nWhen registering vmas for uprobe, skip the vmas in an mm that is marked\nunstable.  Modifying a vma in an unstable mm may cause issues if the mm\nisn't fully initialised."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: kernel: tenga más cuidado con los fallos de dup_mmap() y el registro de uprobe Si una asignación de memoria falla durante dup_mmap(), el árbol de maple puede quedar en un estado inseguro para otros iteradores además de la ruta de salida. Todos los bloqueos se eliminan antes de la llamada a exit_mmap() (en mm/mmap.c), pero se puede llegar al mm_struct incompleto a través de (al menos) el rmap que encuentra los vmas que tienen un puntero de vuelta al mm_struct. Hasta este punto, no ha habido problemas para poder encontrar un mm_struct que solo se haya inicializado parcialmente. Syzbot pudo hacer que el mm_struct incompleto fallara con los cambios de bifurcación recientes, por lo que se ha demostrado que no es seguro usar el mm_struct que no se ha inicializado, como se hace referencia en el enlace a continuación. Aunque 8ac662f5da19f (\"fork: avoid inappropriate uprobe access to invalid mm\") solucionó el acceso a uprobe, no elimina por completo la carrera. Este parche establece MMF_OOM_SKIP para evitar la iteración de las vmas en el lado oom (aunque es extremadamente improbable que se seleccione como víctima de oom en la ventana de carrera), y establece MMF_UNSTABLE para evitar que otros usuarios potenciales utilicen una mm_struct parcialmente inicializada. Al registrar vmas para uprobe, omite las vmas en un mm que esté marcado como inestable. Modificar una vma en un mm inestable puede causar problemas si el mm no está completamente inicializado."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "NVD-CWE-noinfo"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.8",
              "versionEndExcluding": "6.13.2",
              "matchCriteriaId": "869EE8B9-4A29-4120-BAE6-A8581FDD5719"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/64c37e134b120fb462fb4a80694bfb8e7be77b14",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/da139948aeda677ac09cc0e7d837f8a314de7d55",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}