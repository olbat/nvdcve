{
  "id": "CVE-2025-38658",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-08-22T16:15:40.907",
  "lastModified": "2025-08-22T18:08:51.663",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet: pci-epf: Do not complete commands twice if nvmet_req_init() fails\n\nHave nvmet_req_init() and req->execute() complete failed commands.\n\nDescription of the problem:\nnvmet_req_init() calls __nvmet_req_complete() internally upon failure,\ne.g., unsupported opcode, which calls the \"queue_response\" callback,\nthis results in nvmet_pci_epf_queue_response() being called, which will\ncall nvmet_pci_epf_complete_iod() if data_len is 0 or if dma_dir is\ndifferent from DMA_TO_DEVICE. This results in a double completion as\nnvmet_pci_epf_exec_iod_work() also calls nvmet_pci_epf_complete_iod()\nwhen nvmet_req_init() fails.\n\nSteps to reproduce:\nOn the host send a command with an unsupported opcode with nvme-cli,\nFor example the admin command \"security receive\"\n$ sudo nvme security-recv /dev/nvme0n1 -n1 -x4096\n\nThis triggers a double completion as nvmet_req_init() fails and\nnvmet_pci_epf_queue_response() is called, here iod->dma_dir is still\nin the default state of \"DMA_NONE\" as set by default in\nnvmet_pci_epf_alloc_iod(), so nvmet_pci_epf_complete_iod() is called.\nBecause nvmet_req_init() failed nvmet_pci_epf_complete_iod() is also\ncalled in nvmet_pci_epf_exec_iod_work() leading to a double completion.\nThis not only sends two completions to the host but also corrupts the\nstate of the PCI NVMe target leading to kernel oops.\n\nThis patch lets nvmet_req_init() and req->execute() complete all failed\ncommands, and removes the double completion case in\nnvmet_pci_epf_exec_iod_work() therefore fixing the edge cases where\ndouble completions occurred."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nvmet: pci-epf: No completar comandos dos veces si nvmet_req_init() falla. nvmet_req_init() y req-&gt;execute() completan los comandos fallidos. Descripción del problema: nvmet_req_init() llama internamente a __nvmet_req_complete() en caso de fallo (p. ej., un código de operación no compatible, que llama a la devolución de llamada \"queue_response\"). Esto provoca la llamada a nvmet_pci_epf_queue_response(), que a su vez llama a nvmet_pci_epf_complete_iod() si data_len es 0 o si dma_dir es diferente de DMA_TO_DEVICE. Esto genera una doble finalización, ya que nvmet_pci_epf_exec_iod_work() también llama a nvmet_pci_epf_complete_iod() cuando falla nvmet_req_init(). Pasos para reproducir: En el host, envíe un comando con un código de operación no compatible con nvme-cli. Por ejemplo, el comando de administrador \"security receive\": $ sudo nvme security-recv /dev/nvme0n1 -n1 -x4096. Esto activa una doble finalización, ya que nvmet_req_init() falla y se llama a nvmet_pci_epf_queue_response(). En este caso, iod-&gt;dma_dir aún se encuentra en el estado predeterminado \"DMA_NONE\", tal como se establece por defecto en nvmet_pci_epf_alloc_iod(), por lo que se llama a nvmet_pci_epf_complete_iod(). Debido a que nvmet_req_init() falló, nvmet_pci_epf_complete_iod() también se llama en nvmet_pci_epf_exec_iod_work(), lo que provoca una doble finalización. Esto no solo envía dos finalizaciones al host, sino que también corrompe el estado del destino PCI NVMe, lo que provoca errores del kernel. Este parche permite que nvmet_req_init() y req-&gt;execute() completen todos los comandos fallidos y elimina el caso de doble finalización en nvmet_pci_epf_exec_iod_work(), corrigiendo así los casos extremos donde se producían dobles finalizaciones."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/746d0ac5a07d5da952ef258dd4d75f0b26c96476",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a535c0b10060bc8c174a7964b0f98064ee0c4774",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}