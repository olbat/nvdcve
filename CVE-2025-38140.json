{
  "id": "CVE-2025-38140",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-03T09:15:28.617",
  "lastModified": "2025-07-03T15:13:53.147",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm: limit swapping tables for devices with zone write plugs\n\ndm_revalidate_zones() only allowed new or previously unzoned devices to\ncall blk_revalidate_disk_zones(). If the device was already zoned,\ndisk->nr_zones would always equal md->nr_zones, so dm_revalidate_zones()\nreturned without doing any work. This would make the zoned settings for\nthe device not match the new table. If the device had zone write plug\nresources, it could run into errors like bdev_zone_is_seq() reading\ninvalid memory because disk->conv_zones_bitmap was the wrong size.\n\nIf the device doesn't have any zone write plug resources, calling\nblk_revalidate_disk_zones() will always correctly update device.  If\nblk_revalidate_disk_zones() fails, it can still overwrite or clear the\ncurrent disk->nr_zones value. In this case, DM must restore the previous\nvalue of disk->nr_zones, so that the zoned settings will continue to\nmatch the previous value that it fell back to.\n\nIf the device already has zone write plug resources,\nblk_revalidate_disk_zones() will not correctly update them, if it is\ncalled for arbitrary zoned device changes.  Since there is not much need\nfor this ability, the easiest solution is to disallow any table reloads\nthat change the zoned settings, for devices that already have zone plug\nresources.  Specifically, if a device already has zone plug resources\nallocated, it can only switch to another zoned table that also emulates\nzone append.  Also, it cannot change the device size or the zone size. A\ndevice can switch to an error target."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: dm: limitar el intercambio de tablas para dispositivos con conectores de escritura de zona. dm_revalidate_zones() solo permitía que los dispositivos nuevos o previamente no zonificados llamaran a blk_revalidate_disk_zones(). Si el dispositivo ya estaba zonificado, disk-&gt;nr_zones siempre sería igual a md-&gt;nr_zones, por lo que dm_revalidate_zones() regresaba sin realizar ningún trabajo. Esto haría que la configuración zonificada para el dispositivo no coincidiera con la nueva tabla. Si el dispositivo tenía recursos de conector de escritura de zona, podría encontrarse con errores como bdev_zone_is_seq() leyendo memoria no válida porque disk-&gt;conv_zones_bitmap tenía un tamaño incorrecto. Si el dispositivo no tiene ningún recurso de conector de escritura de zona, llamar a blk_revalidate_disk_zones() siempre actualizará correctamente el dispositivo. Si blk_revalidate_disk_zones() falla, aún puede sobrescribir o borrar el valor actual de disk-&gt;nr_zones. En este caso, DM debe restaurar el valor anterior de disk-&gt;nr_zones para que la configuración de zonas siga siendo la misma que la anterior. Si el dispositivo ya cuenta con recursos de complemento de escritura de zona, blk_revalidate_disk_zones() no los actualizará correctamente si se le solicita para realizar cambios arbitrarios en el dispositivo de zona. Dado que esta función no es muy necesaria, la solución más sencilla es impedir cualquier recarga de tabla que modifique la configuración de zonas en los dispositivos que ya cuentan con recursos de complemento de zona. En concreto, si un dispositivo ya tiene asignados recursos de complemento de zona, solo puede cambiar a otra tabla de zonas que también emule la anexión de zona. Además, no puede cambiar el tamaño del dispositivo ni el de la zona. Un dispositivo puede cambiar a un destino de error."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/121218bef4c1df165181f5cd8fc3a2246bac817e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ac8acb0bfd98a1c65f3ca9a3e217a766124eebd8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}