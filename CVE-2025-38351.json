{
  "id": "CVE-2025-38351",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-19T12:15:35.383",
  "lastModified": "2025-08-28T15:15:48.767",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/hyper-v: Skip non-canonical addresses during PV TLB flush\n\nIn KVM guests with Hyper-V hypercalls enabled, the hypercalls\nHVCALL_FLUSH_VIRTUAL_ADDRESS_LIST and HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX\nallow a guest to request invalidation of portions of a virtual TLB.\nFor this, the hypercall parameter includes a list of GVAs that are supposed\nto be invalidated.\n\nHowever, when non-canonical GVAs are passed, there is currently no\nfiltering in place and they are eventually passed to checked invocations of\nINVVPID on Intel / INVLPGA on AMD.  While AMD's INVLPGA silently ignores\nnon-canonical addresses (effectively a no-op), Intel's INVVPID explicitly\nsignals VM-Fail and ultimately triggers the WARN_ONCE in invvpid_error():\n\n  invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000\n  WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482\n  invvpid_error+0x91/0xa0 [kvm_intel]\n  Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse\n  CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary)\n  RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel]\n  Call Trace:\n    vmx_flush_tlb_gva+0x320/0x490 [kvm_intel]\n    kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm]\n    kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm]\n\nHyper-V documents that invalid GVAs (those that are beyond a partition's\nGVA space) are to be ignored.  While not completely clear whether this\nruling also applies to non-canonical GVAs, it is likely fine to make that\nassumption, and manual testing on Azure confirms \"real\" Hyper-V interprets\nthe specification in the same way.\n\nSkip non-canonical GVAs when processing the list of address to avoid\ntripping the INVVPID failure.  Alternatively, KVM could filter out \"bad\"\nGVAs before inserting into the FIFO, but practically speaking the only\ndownside of pushing validation to the final processing is that doing so\nis suboptimal for the guest, and no well-behaved guest will request TLB\nflushes for non-canonical addresses."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86/Hyper-V: Omisión de direcciones no canónicas durante el vaciado de TLB de PV. En invitados KVM con hiperllamadas de Hyper-V habilitadas, las hiperllamadas HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST y HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX permiten que un invitado solicite la invalidación de partes de una TLB virtual. Para ello, el parámetro hypercall incluye una lista de GVA que se supone que deben invalidarse. Sin embargo, cuando se pasan GVA no canónicos, actualmente no hay ningún filtrado implementado y finalmente se pasan a invocaciones comprobadas de INVVPID en Intel / INVLPGA en AMD. Mientras que el INVLPGA de AMD ignora silenciosamente las direcciones no canónicas (efectivamente, una operación nula), el INVVPID de Intel señala explícitamente VM-Fail y, en última instancia, activa WARN_ONCE en invvpid_error(): invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000 WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482 invvpid_error+0x91/0xa0 [kvm_intel] Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary) RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel] Seguimiento de llamadas: vmx_flush_tlb_gva+0x320/0x490 [kvm_intel] kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm] kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm] Hyper-V informa que las GVA no válidas (aquellas que superan el espacio de GVA de una partición) deben ignorarse. Aunque no está del todo claro si esta regla también se aplica a las GVA no canónicas, es probable que sea correcto asumirlo, y las pruebas manuales en Azure confirman que Hyper-V \"real\" interpreta la especificación de la misma manera. Omita las GVA no canónicas al procesar la lista de direcciones para evitar el error INVVPID. Como alternativa, KVM podría filtrar los GVA \"malos\" antes de insertarlos en el FIFO, pero en términos prácticos, la única desventaja de trasladar la validación al procesamiento final es que hacerlo no es óptimo para el invitado y ningún invitado que se comporte bien solicitará vaciados de TLB para direcciones no canónicas."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2d4dea3f76510c0afe3f18c910f647b816f7d566",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d5784ea45663330eaa868c518ea40e7a9f06aa2d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f1b3ad11ec11c88ba9f79a73d27d4cda3f80fb24",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/fa787ac07b3ceb56dd88a62d1866038498e96230",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}