{
  "id": "CVE-2026-23073",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-02-04T17:16:18.027",
  "lastModified": "2026-02-06T17:16:23.230",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rsi: Fix memory corruption due to not set vif driver data size\n\nThe struct ieee80211_vif contains trailing space for vif driver data,\nwhen struct ieee80211_vif is allocated, the total memory size that is\nallocated is sizeof(struct ieee80211_vif) + size of vif driver data.\nThe size of vif driver data is set by each WiFi driver as needed.\n\nThe RSI911x driver does not set vif driver data size, no trailing space\nfor vif driver data is therefore allocated past struct ieee80211_vif .\nThe RSI911x driver does however use the vif driver data to store its\nvif driver data structure \"struct vif_priv\". An access to vif->drv_priv\nleads to access out of struct ieee80211_vif bounds and corruption of\nsome memory.\n\nIn case of the failure observed locally, rsi_mac80211_add_interface()\nwould write struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;\nvif_info->vap_id = vap_idx. This write corrupts struct fq_tin member\nstruct list_head new_flows . The flow = list_first_entry(head, struct\nfq_flow, flowchain); in fq_tin_reset() then reports non-NULL bogus\naddress, which when accessed causes a crash.\n\nThe trigger is very simple, boot the machine with init=/bin/sh , mount\ndevtmpfs, sysfs, procfs, and then do \"ip link set wlan0 up\", \"sleep 1\",\n\"ip link set wlan0 down\" and the crash occurs.\n\nFix this by setting the correct size of vif driver data, which is the\nsize of \"struct vif_priv\", so that memory is allocated and the driver\ncan store its driver data in it, instead of corrupting memory around\nit."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nwifi: rsi: Corrección de corrupción de memoria debido a que no se estableció el tamaño de los datos del controlador vif\n\nLa estructura ieee80211_vif contiene espacio adicional para los datos del controlador vif, cuando se asigna la estructura ieee80211_vif, el tamaño total de memoria que se asigna es sizeof(struct ieee80211_vif) + tamaño de los datos del controlador vif. El tamaño de los datos del controlador vif es establecido por cada controlador WiFi según sea necesario.\n\nEl controlador RSI911x no establece el tamaño de los datos del controlador vif, por lo tanto, no se asigna espacio adicional para los datos del controlador vif más allá de la estructura ieee80211_vif. Sin embargo, el controlador RSI911x utiliza los datos del controlador vif para almacenar su estructura de datos del controlador vif 'struct vif_priv'. Un acceso a vif-&gt;drv_priv conduce a un acceso fuera de los límites de la estructura ieee80211_vif y a la corrupción de parte de la memoria.\n\nEn caso de la falla observada localmente, rsi_mac80211_add_interface() escribiría struct vif_priv *vif_info = (struct vif_priv *)vif-&gt;drv_priv; vif_info-&gt;vap_id = vap_idx. Esta escritura corrompe el miembro de la estructura fq_tin struct list_head new_flows. El flow = list_first_entry(head, struct fq_flow, flowchain); en fq_tin_reset() luego reporta una dirección falsa no-NULL, que al ser accedida causa un fallo.\n\nEl disparador es muy simple, arrancar la máquina con init=/bin/sh, montar devtmpfs, sysfs, procfs, y luego ejecutar 'ip link set wlan0 up', 'sleep 1', 'ip link set wlan0 down' y el fallo ocurre.\n\nSolucionar esto estableciendo el tamaño correcto de los datos del controlador vif, que es el tamaño de 'struct vif_priv', para que se asigne memoria y el controlador pueda almacenar sus datos de controlador en ella, en lugar de corromper la memoria a su alrededor."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0d7c9e793e351cbbe9e06a9ca47d77b6ad288fb0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/31efbcff90884ea5f65bf3d1de01267db51ee3d1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/49ef094fdbc3526e5db2aebb404b84f79c5603dc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4f431d88ea8093afc7ba55edf4652978c5a68f33",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7761d7801f40e61069b4df3db88b36d80d089f8a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7c54d0c3e2cad4300be721ec2aecfcf8a63bc9f4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/99129d80a5d4989ef8566f434f3589f60f28042b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}