{
  "id": "CVE-2025-37856",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-05-09T07:16:06.593",
  "lastModified": "2025-05-12T17:32:52.810",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: harden block_group::bg_list against list_del() races\n\nAs far as I can tell, these calls of list_del_init() on bg_list cannot\nrun concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim(),\nas they are in transaction error paths and situations where the block\ngroup is readonly.\n\nHowever, if there is any chance at all of racing with mark_bg_unused(),\nor a different future user of bg_list, better to be safe than sorry.\n\nOtherwise we risk the following interleaving (bg_list refcount in parens)\n\nT1 (some random op)                       T2 (btrfs_mark_bg_unused)\n                                        !list_empty(&bg->bg_list); (1)\nlist_del_init(&bg->bg_list); (1)\n                                        list_move_tail (1)\nbtrfs_put_block_group (0)\n                                        btrfs_delete_unused_bgs\n                                             bg = list_first_entry\n                                             list_del_init(&bg->bg_list);\n                                             btrfs_put_block_group(bg); (-1)\n\nUltimately, this results in a broken ref count that hits zero one deref\nearly and the real final deref underflows the refcount, resulting in a WARNING."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: endurecer block_group::bg_list contra ejecuciones list_del() Hasta donde puedo decir, estas llamadas de list_del_init() en bg_list no se pueden ejecutar simultáneamente con btrfs_mark_bg_unused() o btrfs_mark_bg_to_reclaim(), ya que están en rutas de error de transacción y situaciones en las que el grupo de bloques es de solo lectura. Sin embargo, si hay alguna posibilidad de competir con mark_bg_unused(), o con un futuro usuario diferente de bg_list, más vale prevenir que curar. De lo contrario, nos arriesgamos al siguiente intercalado (bg_list refcount entre paréntesis) T1 (alguna operación aleatoria) T2 (btrfs_mark_bg_unused) !list_empty(&amp;bg-&gt;bg_list); (1) list_del_init(&amp;bg-&gt;bg_list); (1) list_move_tail (1) btrfs_put_block_group (0) btrfs_delete_unused_bgs bg = list_first_entry list_del_init(&amp;bg-&gt;bg_list); btrfs_put_block_group(bg); (-1) En última instancia, esto da como resultado un recuento de referencias roto que llega a cero un deref antes y el deref final real desborda el recuento de referencias, lo que genera una ADVERTENCIA."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/185fd73e5ac06027c4be9a129e59193f6a3ef202",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7511e29cf1355b2c47d0effb39e463119913e2f6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/909e60fb469d4101c6b08cf6e622efb062bb24a1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/bf089c4d1141b27332c092b1dcca5022c415a3b6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}