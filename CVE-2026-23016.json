{
  "id": "CVE-2026-23016",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2026-01-31T12:16:04.900",
  "lastModified": "2026-02-03T16:44:36.630",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ninet: frags: drop fraglist conntrack references\n\nJakub added a warning in nf_conntrack_cleanup_net_list() to make debugging\nleaked skbs/conntrack references more obvious.\n\nsyzbot reports this as triggering, and I can also reproduce this via\nip_defrag.sh selftest:\n\n conntrack cleanup blocked for 60s\n WARNING: net/netfilter/nf_conntrack_core.c:2512\n [..]\n\nconntrack clenups gets stuck because there are skbs with still hold nf_conn\nreferences via their frag_list.\n\n   net.core.skb_defer_max=0 makes the hang disappear.\n\nEric Dumazet points out that skb_release_head_state() doesn't follow the\nfraglist.\n\nip_defrag.sh can only reproduce this problem since\ncommit 6471658dc66c (\"udp: use skb_attempt_defer_free()\"), but AFAICS this\nproblem could happen with TCP as well if pmtu discovery is off.\n\nThe relevant problem path for udp is:\n1. netns emits fragmented packets\n2. nf_defrag_v6_hook reassembles them (in output hook)\n3. reassembled skb is tracked (skb owns nf_conn reference)\n4. ip6_output refragments\n5. refragmented packets also own nf_conn reference (ip6_fragment\n   calls ip6_copy_metadata())\n6. on input path, nf_defrag_v6_hook skips defragmentation: the\n   fragments already have skb->nf_conn attached\n7. skbs are reassembled via ipv6_frag_rcv()\n8. skb_consume_udp -> skb_attempt_defer_free() -> skb ends up\n   in pcpu freelist, but still has nf_conn reference.\n\nPossible solutions:\n 1 let defrag engine drop nf_conn entry, OR\n 2 export kick_defer_list_purge() and call it from the conntrack\n   netns exit callback, OR\n 3 add skb_has_frag_list() check to skb_attempt_defer_free()\n\n2 & 3 also solve ip_defrag.sh hang but share same drawback:\n\nSuch reassembled skbs, queued to socket, can prevent conntrack module\nremoval until userspace has consumed the packet. While both tcp and udp\nstack do call nf_reset_ct() before placing skb on socket queue, that\nfunction doesn't iterate frag_list skbs.\n\nTherefore drop nf_conn entries when they are placed in defrag queue.\nKeep the nf_conn entry of the first (offset 0) skb so that reassembled\nskb retains nf_conn entry for sake of TX path.\n\nNote that fixes tag is incorrect; it points to the commit introducing the\n'ip_defrag.sh reproducible problem': no need to backport this patch to\nevery stable kernel."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\ninet: frags: eliminar referencias de conntrack de fraglist\n\nJakub añadió una advertencia en nf_conntrack_cleanup_net_list() para hacer más obvia la depuración de skbs/referencias de conntrack filtradas.\n\nsyzbot informa que esto se activa, y también puedo reproducirlo a través de la autoprueba ip_defrag.sh:\n\nlimpieza de conntrack bloqueada durante 60s\nADVERTENCIA: net/netfilter/nf_conntrack_core.c:2512\n[..]\n\nLas limpiezas de conntrack se atascan porque hay skbs que aún mantienen referencias nf_conn a través de su frag_list.\n\nnet.core.skb_defer_max=0 hace que el cuelgue desaparezca.\n\nEric Dumazet señala que skb_release_head_state() no sigue la fraglist.\n\nip_defrag.sh solo puede reproducir este problema desde el commit 6471658dc66c ('udp: use skb_attempt_defer_free()'), pero AFAICS este problema también podría ocurrir con TCP si el descubrimiento de pmtu está desactivado.\n\nLa ruta del problema relevante para udp es:\n1. netns emite paquetes fragmentados\n2. nf_defrag_v6_hook los reensambla (en el hook de salida)\n3. el skb reensamblado es rastreado (skb posee la referencia nf_conn)\n4. ip6_output refragmenta\n5. los paquetes refragmentados también poseen la referencia nf_conn (ip6_fragment llama a ip6_copy_metadata())\n6. en la ruta de entrada, nf_defrag_v6_hook omite la desfragmentación: los fragmentos ya tienen skb-&gt;nf_conn adjunto\n7. los skbs son reensamblados a través de ipv6_frag_rcv()\n8. skb_consume_udp -&gt; skb_attempt_defer_free() -&gt; skb termina en la freelist de pcpu, pero aún tiene la referencia nf_conn.\n\nPosibles soluciones:\n1 dejar que el motor de desfragmentación elimine la entrada nf_conn, O\n2 exportar kick_defer_list_purge() y llamarlo desde la devolución de llamada de salida de netns de conntrack, O\n3 añadir una comprobación skb_has_frag_list() a skb_attempt_defer_free()\n\n2 y 3 también resuelven el cuelgue de ip_defrag.sh pero comparten el mismo inconveniente:\n\nTales skbs reensamblados, encolados al socket, pueden impedir la eliminación del módulo conntrack hasta que el espacio de usuario haya consumido el paquete. Si bien tanto la pila tcp como udp llaman a nf_reset_ct() antes de colocar el skb en la cola del socket, esa función no itera los skbs de frag_list.\n\nPor lo tanto, eliminar las entradas nf_conn cuando se colocan en la cola de desfragmentación.\nMantener la entrada nf_conn del primer skb (offset 0) para que el skb reensamblado retenga la entrada nf_conn para la ruta TX.\n\nTenga en cuenta que la etiqueta de correcciones es incorrecta; apunta al commit que introdujo el 'problema reproducible de ip_defrag.sh': no es necesario hacer un backport de este parche a cada kernel estable."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/088ca99dbb039c444c3ff987c5412a73f4f0cbf8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2ef02ac38d3c17f34a00c4b267d961a8d4b45d1a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}